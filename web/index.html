<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width,height=device-height, user-scalable=no" />
  <title>Overflight editor</title>
  <link rel="stylesheet" href="https://npmcdn.com/leaflet@1.2.0/dist/leaflet.css" />
  <script src="./node_modules/leaflet/dist/leaflet.js"></script>
  <script src="node_modules/leaflet-toolbar/dist/leaflet.toolbar.js"></script>
  <link rel="stylesheet" href="node_modules/leaflet-toolbar/dist/leaflet.toolbar.css"/>
  <script src="./js/leaflet-providers.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
  <link href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" rel="stylesheet" id="bootstrap-css">
  <script src="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"></script>

  <style type='text/css'>
      body { 
        height: 100%; 
        width: 100%; 
        background-color: rgb(50, 50, 50);
      }
      

      #menu-container {
        position: relative;
        border: 5px;
        border-color: rgb(100, 100, 100);
        height: 100%;
      }
      
      /*#map { 
        position: relative; 
        min-height: 650px;
        margin-bottom: 0;
        margin-top: 0;
        width: 100%;
      }*/

      .leaflet-popup-content-wrapper {
        background-color: rgb(85, 85, 85);
        color: rgb(145, 145, 145);
      }

      .leaflet-popup-tip {
        background-color: rgb(85, 85, 85);
      }

      .leaflet-popup-content p{
        margin: 3px;
      }
      /*.card-header {
        background-color: rgb(60, 60, 60);
        border-bottom:  
      }*/
      .card {
        /*height: 60px;*/
        /*border: 2px solid rgb(100, 100, 100);*/
        color: rgb(125, 125, 125);
        background-color: rgb(75, 75, 75);

      }

      .card-header a{
        transition: 0.3s;
        color: rgb(125, 125, 125);
      }

      .card-header a:hover {
        /*font-weight: bold;*/
        color: rgb(150, 150, 150);
        cursor: pointer;
      }

      .card-header-anchor-selected {
        color: rgb(150, 150, 150);
      }

      .card-header a.card-header-anchor-selected{
        transition: 0.3s;
        color: hsl(195, 84%, 61%);
      }

      .show {
        max-height: 20%;
        /*border: 4px solid rgb(100, 100, 100);*/
        /*font-weight: bold;*/
        color: rgb(125, 125, 125);
        background-color: rgb(60, 60, 60);
        /*box-shadow: 0px 16px 16px 0 rgba(0,0,0,0.2);*/
        text-align: center;
      }

      .card-footer {
        height: 30px;
        background-color: rgb(60, 60, 60);
      }
      /*.show:hover {
        cursor: auto;
        border: 4px solid rgb(100, 100, 100);
      }*/

      .legend-row {
        height: 50px;
        width: 100%;
        transition: 0.2s;
      }
      
      .legend-row:hover {
        color: rgb(120, 120, 120);
        background-color: hsl(204, 5%, 27%);
        /*background-color: rgb(65, 65, 70);*/
        cursor: pointer;
      }

      .legend-row-selected {
        height: 50px;
        background-color: hsl(204, 15%, 30%);
        /*background-color: rgb(80, 80, 90);*/
        cursor: auto;
      }

      .legend-cell {
        color: rgb(110, 110, 110);
        text-align: center;
        display: inline-block;
        vertical-align: middle;
        transition: 0.2s;
        height: 100%;
        padding-top: 12px;
        padding-bottom: 12px;
      }

      .legend-cell:hover {
        color: rgb(120, 120, 120);
      }

      .legend-cell-selected {
        color: rgb(130, 130, 130);
        text-align: center;
        display: inline-block;
        vertical-align: middle;
        height: 100%;
        padding-top: 12px;
        padding-bottom: 12px;
      }
      
      .vertical-center {
        margin: 0;
        position: absolute;
        top: 50%;
        -ms-transform: translateY(-50%);
        transform: translateY(-50%);
      }

      .delete-button {
        border: none; 
        background: url(imgs/delete_icon_20px.png); 
        opacity: 0.25;
        height: 20px; 
        width: 20px;
        transition: 0.3s;
        cursor: pointer;
      }

      .delete-button:hover {
        opacity: 0.5;
      }

      #dashboard-container {
        padding: 20;
      }

      .data-button {
        height: 50px;
        width: 150px;
        top: 10px;
        position: relative;
        /*padding: 14px 28px;*/
        font-size: 16px;
        background-color: rgb(125, 125, 125);
        color: rgb(200, 200, 200);
        border: none;
        display: inline-block;
        transition: 0.4s;
      }

      .data-button:hover {
        background-color: hsl(195, 50%, 45%);
        /*color: hsl(38, 95%, 45%);*/
      }

      td {
        color: rgb(100, 100, 100);
        text-align: center;
      }

      .dark-scrollbar {
        overflow-y: auto;
      }
      .dark-scrollbar::-webkit-scrollbar-track {
          background-color: rgb(60, 60, 60);
      }
      .dark-scrollbar::-webkit-scrollbar-thumb {
          background-color: rgb(110, 110, 110);
      }


      /* Custom checkbox*/
      /* The container */
      .checkmark-container {
        display: block;
        position: relative;
        cursor: pointer;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        height: 100%;
        width: 100%;
      }

      /* Hide the browser's default checkbox */
      .checkmark-container input {
        position: absolute;
        opacity: 0;
        cursor: pointer;
        height: 0;
        width: 0;
      }

      /* Create a custom checkbox */
      .checkmark {
        position: absolute;
        top: 0;
        left: 0;
        height: 20px;
        width: 20px;
        background-color: none;
        border: 2px solid rgb(90, 90, 90);
        vertical-align: center;
        horizontal-align: center;
      }

      /*When the checkbox is checked, make the background lighter*/ 
      .checkmark-container input:checked ~ .checkmark {
        background-color: rgb(100, 100, 100);
        border: none;
      }

      /* Create the checkmark/indicator (hidden when not checked) */
      .checkmark:after {
        content: "";
        position: absolute;
        /*display: none;*/
        opacity: 0;
      }

      /* Show the checkmark when checked */
      .checkmark-container input:checked ~ .checkmark:after {
        /*display: block;*/
        opacity: 1;
      }

      /* Style the checkmark/indicator */
      .checkmark-container .checkmark:after {
        left: 7px;
        top: 2px;
        width: 7px;
        height: 12px;
        border: solid rgb(180, 180, 180);
        border-width: 0 2px 2px 0;
        -webkit-transform: rotate(45deg);
        -ms-transform: rotate(45deg);
        transform: rotate(45deg);
        vertical-align: center;
      }

      /* Track info form*/
      input {
        box-sizing: border-box;

      }

      #button-track-info-lock {
        float: right; 
        border: none; 
        background: url('imgs/lock_icon_25px.png'); 
        opacity: 0.40; 
        height: 25px;  
        width: 20px; 
        transition: 0.3s; 
        cursor: pointer;
        transition: 0.2s;
      }
      
      #button-track-info-lock:focus {
        outline: 0;
      } 
      /*#button-track-info-lock:hover {
        opacity: 0.55;
      }*/

      #button-track-info-lock.unlocked {
        background: url('imgs/unlock_icon_25px.png'); 
      }

      .track-info-label {
        color: rgb(125, 125, 125);
        display: block;
        margin-bottom: 10px;
      }
      .track-info-textbox {
        color: rgb(135, 135, 135);
        background-color: rgb(75, 75, 75);
        border: none;
        display: block;
        width: 100%;
        min-width: 80px;
        height: 40px;
        padding-left: 7px;
      }

      input[type="text"]:focus {
        -webkit-box-shadow: none;
        outline: -webkit-focus-ring-color auto 0px;
        border: solid 1.5px hsl(195, 65%, 42%);/*hsl(38, 85%, 30%);*/
      }

      .input-container {
        display: inline-block; 
        width: 50%; 
        padding: 15px;
      }

      select {
        color: rgb(135, 135, 135);
        background-color: rgb(75, 75, 75);
        border: none;
        display: block;
        width: 100%;
        min-width: 80px;
        height: 40px;
        padding-left: 7px;
        -webkit-box-shadow: none;
        outline: -webkit-focus-ring-color auto 0px;
      }

      select:focus {
        border: solid 1.5px hsl(195, 65%, 42%);
      }

      .track-info-option {
        background-color: rgb(85, 85, 85) !important;
        color: rgb(145, 145, 145) !important;
        border: none !important;
      }

      select option:selected {
        background-color: hsl(204, 5%, 27%) !important;
      }

      .track-info-textbox.locked {
        border: solid 2px rgb(75, 75, 75);
        background: none;
        color: rgb(125, 125, 125);
      }

      .select-disabled {
        -webkit-appearance: none;
        background-color: rgb(67, 67, 67);
      }

      .select-disabled-label {
        color: rgb(90, 90, 90);
      }

  </style>
</head>

<body>

  <div id="dashboard-container" class="container-fluid" style="display:flex;">
    
    <div class="row h-100" style="display: flex; width:100%">
      
      <div id='menu-container' class="col-sm-6 col-md-4 col-lg-4" style="">
        <div>
          <!-- File menu and legend-->
          <h4 style="color: rgb(110, 110, 110);">Files to import</h4>
          <div style="height:100%; overflow:auto; align-items:stretch;" >
            <div class='accordion' id='file-list'>
              <!--items added dynamically on load -->
            </div>
          </div>
        </div>

        <div class="dark-scrollbar" id="track-info-panel" style="width:100%; display: flex; flex-direction: column; flex:1; background-color: rgb(60, 60, 60); padding: 20px;">
          <!-- Info about each track-->
          <div style="display:flex;">
            <div style="color: rgb(110, 110, 110); width:100%">
              <!--<div style="display: block; width: 100%">-->
              <h4 style="display: inline-block; float: left; color: inherit">Track info</h4>
              <button id="button-track-info-lock" style="display: inline-block;" onclick="lockButtonClick()"></button>

            <div style="float: left; width:100%">
              <p id="p-submitted-at" style="color: inherit; font-size:14px; padding: 0px; margin-bottom:4px;"> </p>
              <p id="p-submitted-by" style="color: inherit; font-size:14px; padding: 0px;"> </p>
            </div>
            </div>
          </div>
          <form id="form-track-info" style="width: 100%; position: relative;">
            
            <div class="row" style="display: flex;">
              <div class="input-container">
                <label class="track-info-label">Tail number</label>
                <input type="text" class="track-info-textbox locked" id="textbox-registration" name="registration" spellcheck="false" disabled="true">
              </div>
              <div class="input-container">
                <label class="track-info-label">Editor</label>
                <input type="text" class="track-info-textbox locked" id="textbox-track_editor" name="editor" spellcheck="false" disabled="true">
              </div>
            </div>
            
            <div class="row" style="display: flex;">
              <div class="input-container">
                <label class="track-info-label">Operator code</label>
                <select class="track-info-textbox locked" id="select-operator_code" name="operator_code" disabled="true">
                  <option class="track-info-option" value=""></option><!--make first option blank-->
                </select>
              </div>
              <div class="input-container">
                <label class="track-info-label" id="label-tracks_mission">NPS mission code</label>
                <select class="track-info-textbox locked" id="select-tracks_mission" name="mission_code" disabled="true">
                  <option class="track-info-option" value=""></option>
                </select>
              </div>
            </div>

            <div class="row" style="display: flex;">
              <div class="input-container" style="width:100%">
                <label class="track-info-label">Submitter notes</label>
                <div class="track-info-textbox locked" style="height:80px; overflow-y:auto; padding:7px;">
                  <p id="p-submitter_notes" style="width:100%"></p>
                </div>
              </div>
            </div>

          </form>
        </div>
      </div>
      
      <div id='map-container' class="col-sm-6 col-md-8 col-lg-8" style="display: inline-block;">
        <div id='map'style="position: relative; min-height: 650px; margin-bottom: 0; margin-top: 0; width: 100%; height:90%;">
        </div>

        <div class="row" style="top: 10px;">
          <div class="col-sm-2">
            <button class="button data-button" id="save-button" onclick="writeJSON()">Save tracks</button>
          </div>

          <div class="col-sm-2">
            <!--<button class="button data-button" id="save-button">Import data</button>-->
          </div>          
        </div>
      </div>
    
    </div>

  </div>

  <script type="text/javascript">


    function getColor() {
      var color = Math.floor(Math.random() * 16777216).toString(16);
      var hexColor = '#000000'.slice(0, -color.length) + color;

      return hexColor;
    }


    function getSelectedFileName() {
      try {
        return $('.card-header-anchor-selected.card-link.text-center > .card-title').text();
      } catch {
        return '';
      }
    }


    function splitAtVertex(segmentID, vertexID, minVertexIndex){
      /*
      Split a line at the associated vertex. vertexID is the ID of the 
      point from the geojson used to create it
      */

      var fileName = getSelectedFileName();//$('.collapse.show').text();
      var originalLine = lineLayers[fileName][segmentID];
      var allLatlngs = originalLine.getLatLngs();

      // vertexID is a global ID so calculate the index within the latlngs array
      var vertexIndex = vertexID - minVertexIndex 

      var originalLatlngs = allLatlngs.slice(0, (vertexIndex + 1));
      var newLatLngs = allLatlngs.slice(vertexIndex);
      
      // Set coords for the old line (everything up to the vertex) and 
      //  create the new line (the new vertex and everything after)
      originalLine.setLatLngs(originalLatlngs);
      var newSegmentID = Math.max.apply(null, Object.keys(lineLayers[fileName])) + 1;
      var newColor = getColor();
      colors[fileName][newSegmentID] = newColor;
      var newLine = L.polyline(
        newLatLngs, 
        options={color: newColor})
      .addEventListener({click: onLineClick})
      .addTo(map);
      lineLayers[fileName][newSegmentID] = newLine;

      // Create the new point geojson by looping through all points 
      //  of the original and adding each .feature to the json
      var newDepartureTime = pointGeojsonLayers[fileName][segmentID].toGeoJSON().features[vertexIndex].properties.ak_datetime
      var newGeoJSON = {
        type: "FeatureCollection",
        features: []
      }
      pointGeojsonLayers[fileName][segmentID].eachLayer(
        function(layer) {
          var featureID = layer.feature.id;
          var theseCordinates = layer.feature.geometry.coordinates
          var theseProperties = layer.feature.properties
          // only add this point if it occurs after the splitting vertex
          //  (or if it is that vertex)
          if (featureID >= vertexID) {
            // set the mapID to the new segment ID so the points 
            //  are still related to the line
            theseProperties.mapID = newSegmentID;
            theseProperties.min_index = vertexID;
            layer.feature.properties.departure_datetime = newDepartureTime;
            // add this feature
            newGeoJSON.features.push(layer.feature);

            // if this feature isn't the splitting vertex, 
            //  drop it from the original point layer
            if (featureID > vertexID) {
              pointGeojsonLayers[fileName][segmentID].removeLayer(layer)
            };
          }
        }
      )
      pointGeojsonLayers[fileName][newSegmentID] = L.geoJSON(newGeoJSON, { 
        onEachFeature: ((feature, layer) => onEachPoint(feature, layer, fileName)), 
        pointToLayer: ((feature, latlng) => geojsonPointAsCircle(feature, latlng, newColor))
      });

      // Update the legend
      var thisInfo = newGeoJSON.features[0].properties;
      thisInfo['visible'] = true;
      trackInfo[fileName][newSegmentID] = thisInfo;
      showVertices(newSegmentID);
      updateLegend(fileName);
    }


    function onPointClick(event, segmentID, vertexID, minVertexIndex) {
      if (event.originalEvent.ctrlKey) {
        splitAtVertex(segmentID, vertexID, minVertexIndex)
      }
    }


    function onEachPoint(feature, layer, fileName) {
      /*
      For each point, add the coordinates to a dictionary of 
      segmentID: [coords] so lines can be created later  
      */
      var properties = feature.properties
      var segmentID = properties.segment_id;
      
      // mapID is used to keep track of lines and points on the map. 
      //  They could be split, which would make the mapID different 
      //  from the segment_id. If the mapID is already set though, 
      //  that means that this feature was created by splitAtVertex(), 
      //  so don't reassign it
      if (feature.properties["mapID"] == undefined) {
        feature.properties["mapID"] = segmentID;
      }
      
      layer.addEventListener({
        click: (e => onPointClick(e, properties.mapID, properties.point_index, properties.min_index))
      });

      // Add coordinates to dict of coordinate arrays for creating lines later
      var pointCoords = feature.geometry.coordinates;
      if (lineCoords[fileName][segmentID] === undefined) {
        // coords in geojson are [x, y] but polyline needs [lat, lon]
        lineCoords[fileName][segmentID] = [[pointCoords[1], pointCoords[0]]]
      } else {
        lineCoords[fileName][segmentID].push([pointCoords[1], pointCoords[0]])
      }

    }


    function geojsonPointAsCircle(feature, latlng, color) {
      var markerOptions = {
        radius: 8,
        weight: 1,
        opacity: 1,
        fillOpacity: 0.8,
        fillColor: color,
        color: color
      }

      var popup = L.popup({
        autoPan: false,

      })
        .setContent(`
          <div>
            <p><strong>Time:</strong> ${feature.properties.ak_datetime}</p>
            <p><strong>Altitude:</strong> ${feature.properties.altitude_ft} ft</p>
          </div>
        `);

      return L.circleMarker(latlng, markerOptions)
        .bindPopup(popup);
    }


    function showVertices(id, hideCurrent=true) {

      var fileName = getSelectedFileName();

      var currentLineID = selectedLines[fileName];
      if (currentLineID >= 0 && hideCurrent) {
        hideVertices(currentLineID);
      }
      
      var geojsonPoints = pointGeojsonLayers[fileName][id];
      map.addLayer(geojsonPoints);

      // layer.bringToFront() requires that the layers are added to the 
      //  map div first, which doesn't happen until the map view is set. 
      //  This can either happen with map.setView() or map.fitBounds().
      var layerBounds = geojsonPoints.getBounds();
      try {
        // First try to set the view as the current view (i.e., don't move the map).
        //  This fails if the map view hasn't been set yet and therefore doesn't 
        //  have a "center"
        map.setView(map.getCenter());
      } catch {
        // If that doesn't work, fit the map to the currently selected layer
        map.fitBounds(layerBounds);
      }
      
      // If the layer isn't visible within the view, set the view to 
      //  the entire file extent
      if (!map.getBounds().intersects(layerBounds)) {
        map.fitBounds(fileExtents[fileName]);
      }

      lineLayers[fileName][id].bringToFront();
      geojsonPoints.bringToFront();

      selectedLines[fileName] = id;
      
    }


    function hideVertices(id) {
      var fileName = getSelectedFileName();//currentFile//$('.collapse.show').text()
      map.removeLayer(pointGeojsonLayers[fileName][id]); 

      //unselect this legend item (if it's selected)
      $('#legend-' + fileName + '-' + id)
        .removeClass('legend-row-selected')
        .addClass('legend-row')
        .children()
          .removeClass('legend-cell-selected')
          .addClass('legend-cell');
    }


    function getLineID(layer) {
      var fileName = getSelectedFileName();//currentFile//$('.collapse.show').text()
      for (var segmentID in lineLayers[fileName]) {
        if (lineLayers[fileName][segmentID] == layer) {
          return segmentID;
        }
      }
    }


    function selectLegendItem(id) {
      /* 
      Make item look selected in the legend
      */

      var fileName = getSelectedFileName()
      // Deselect all currently selected cell (<td>) items,
      //  which actually contain the formatting
      $('.legend-cell-selected')
        .removeClass('legend-cell-selected')
        .addClass('legend-cell');
      
      // Remove the selection class from the row (<tr>)
      $('.legend-row-selected')
        .removeClass('legend-row-selected')
        .addClass('legend-row')

      // The row was a assigned the id, so get it's children (the <td>s)
      //  and add the class that contains the 
      $('#legend-' + fileName + '-' + id)
        .removeClass('legend-row')
        .addClass('legend-row-selected')
        .children()
        .removeClass('legend-cell')
        .addClass('legend-cell-selected');

      // If the checkbox was unselected, select it
      // This only works if legend-row events are filtered and only allowed 
      //  to propogate if the event didn't originate on a checkbox
      var thisCheckbox = $(`#legend-checkmark-${fileName}-${id}`);
      if (!thisCheckbox.prop('checked') && lineLayers[fileName][id] != undefined) {
        thisCheckbox.prop('checked', true);
        lineLayers[fileName][id].addTo(map);
      }

      var scrollPosition = $(`#legend-${fileName}`).scrollTop();
      var rowHeight = parseInt($(`#legend-${fileName}-${id}`).css('height').replace('px', ''));
      var legendHeight = parseInt($(`#legend-${fileName}`).css('height').replace('px', ''));
      var scrollTo = id * rowHeight;

      // scroll to the row if it's off the screen
      if (scrollTo < scrollPosition || scrollTo > scrollPosition + legendHeight - rowHeight) {
        $(`#legend-${fileName}`)
          .animate(
            {scrollTop: scrollTo < 0 ? 0 : scrollTo}, 
            300
          );
      } 
    }


    function onLineClick(e) {
      /*
      When a line is clicked, hide the vertices of the active 
      line and show this line's vertices
      */

      if (!e.originalEvent.ctrlKey) {
        var thisLineID = getLineID(e.target);

        showVertices(thisLineID);

        selectLegendItem(thisLineID);

        L.DomEvent.stop(e) // don't propagate to the map
      }
    }


    function deleteTrack(id=undefined) {
      /*
      Remove the currently selected line and points from the 
      map and delete references to them
      */

      var fileName = getSelectedFileName();
      var thisID = id === undefined ? selectedLines[fileName] : id;
      if (thisID >= 0 && confirm(`Are you sure you want to delete the selected track?`)) {
        map.removeLayer(pointGeojsonLayers[fileName][thisID]);
        map.removeLayer(lineLayers[fileName][thisID]);
        delete pointGeojsonLayers[fileName][thisID];
        delete lineLayers[fileName][thisID];
        delete trackInfo[fileName][thisID];
        $(`#legend-${fileName}-${thisID}`)
          .fadeOut(500, function() {$(this).remove()});// remove the item from the legend
        
        // Only reset the selected line if this line is the currently selected one
        if (thisID == selectedLines[fileName]) {
          selectedLines[fileName] = -1;
        }
      } 
      //updateLegend();

    }


    function onKeyDown(e) {

      if (e.key === 'Delete') {
        var fileName = getSelectedFileName();
        if (selectedLines[fileName] === undefined || selectedLines[fileName] < 0) {
          alert(`No track is currently selected. Click a track first then press 
            'Delete' or click a delete button in the legend`)
        } else {
          deleteTrack();
        }
      }
    }
    

    function onMapClick(e) {
      /*
      If the map is clicked (not a polyline layer), deselect the current layer
      */

      var fileName = getSelectedFileName()
      var currentLineID = selectedLines[fileName]
      if (currentLineID >= 0 && !e.originalEvent.ctrlKey) {
        hideVertices(currentLineID);
        selectedLines[fileName] = -1;
      }
    }


    function addFileToMenu(filePath) {
       
       var fileName = filePath.replace('data/', '').replace('.json', '');
       //$('<tr><td class="file-list-row">' + fileName + '</td></tr>')
       //.appendTo('#files-table')
       var cardID = 'card-' + fileName;
       var cardHeaderID = 'cardHeader-' + fileName;
       var contentID = 'cardContent-' + fileName;
       // add the card
       $('<div class="card" id="' + cardID + '">' + 
            '<div class="card-header px-0" id="' + cardHeaderID + '"></div>' +
          '</div>'
        ).appendTo('#file-list');

       // add an anchor to the card header
       $(`<a class="collapsed card-link text-center" data-toggle="collapse" href="#${contentID}">
            <p class="card-title">${fileName}</p>
          </a>`)
       .appendTo('#' + cardHeaderID)
       .on('click', function() {
        if (!$(this).hasClass('card-header-anchor-selected')){

          // Make sure the new card is given the selected class before trying to load data
          fileWasSelected(fileName);
          
          // If the points don't yet exist, this file hasn't been loaded, so load them
          if (pointGeojsonLayers[fileName] == undefined) {
            loadTracksFromJSON(filePath);
          } else {
            loadTracksFromMemory(fileName);
          }
        }
       });

       // Add the card content to the card
       $('<div id="' + contentID + '" class="collapse" aria-labeledby="' + cardHeaderID + '" data-parent="#file-list">' + 
          '<div class="card-body p-0" id="' + contentID + '-body">' +
            '<div class="dark-scrollbar" id="legend-' + fileName + '" style="display:block; width:100%; overflow:auto; max-height:250px;"></div>' +
          '</div>' +
          '<div class="card-footer"></div>' +
        '</div>'
        ).appendTo('#' + cardID);

    }


    function updateLegend(fileName){

      var legendID = 'legend-' + fileName;
      $('#' + legendID).empty();
      
      // Add a new row for each track
      for (segmentID in trackInfo[fileName]) {
        /*// If the element already exists, skip it
        if ($(`#legend-${fileName}-${segmentID}`).length) {
          continue;
        }*/
        var thisInfo = trackInfo[fileName][segmentID];
        var thisColor = colors[fileName][segmentID];
        var htmlString = 
        `
        <div class="legend-row" id="legend-${fileName}-${segmentID}" style="width: 100%;">
          <div class="legend-cell px-10" style="width:60px; text-align:right;">
            <svg height="10" width="60">
              <line x1="0" y1="5" x2="50" y2="5" style="stroke:${thisColor}; stroke-width:3;"></line>
            </svg>
          </div>
          <div class="legend-cell" style="width:40%; max-width: 60%; text-align:left;">${thisInfo.departure_datetime}</div>
          <div class="legend-cell" style="max-width:10%; width:10%; margin-left:10px; margin-right:10px;">
            <button class="delete-button" onclick="deleteTrack(${segmentID})"></button>
          </div>
          <div class="legend-cell" style="text-align:center; max-width:10%; width:10%; padding-right:10px; padding-left:10px;">
            <label class="checkmark-container">
              <input type="checkbox" checked="checked" id="legend-checkmark-${fileName}-${segmentID}">
              <span class="checkmark"></span>
            </label>
          </div>
        </div>
        `;
        var legendItem = $(htmlString)
          .click(function(event) {
            // If the event originated on a checkbox, exit
            if ($(event.target).hasClass('checkmark') || $(event.target).attr('checked') || $(event.target).hasClass('delete-button')) {
              return;
            }


            var thisID = $(this)[0].id.replace('legend-' + fileName + '-', '');
            showVertices(thisID);
            selectLegendItem(thisID);
          })
          .appendTo('#' + legendID);

        // Handle clicks on this item's checkbox
        $('#legend-checkmark-' + fileName + '-' + segmentID).change(function(event) {
          
          var thisID = $(this)[0].id.replace(`legend-checkmark-${fileName}-` , '');
          if (!this.checked) {// state is after click
            if (thisID == selectedLines[fileName]) {
              hideVertices(thisID);
            }
            map.removeLayer(lineLayers[fileName][thisID]);
            trackInfo[fileName][thisID].visible = false;
          } else {
            map.addLayer(lineLayers[fileName][thisID]);
            trackInfo[fileName][thisID].visible = true;
          }
          
          // Make sure the click doesn't continue to the .legend-row and highlight it
          event.stopPropagation();
        })
        
      }
      
      // select the row corresponding to the selected line
      selectLegendItem(selectedLines[fileName]);
      //console.log($('#legend_0'))
    }


    function removeAllLayers() {
      
      map.eachLayer( function(layer) {
        if (!(layer instanceof L.TileLayer) && !(layer instanceof L.Toolbar2)) {
          map.removeLayer(layer);
        }
      })
    }


    function fileWasSelected(filePath) {

      // remove selection if this is not the currently selected file.
      //  otherwise, add -selected style
      $('.collapse.show').collapse('hide')

      var fileName = filePath.replace('data/', '').replace('.json', '');
      
      // remove selected class styling from the .card-header anchor
      var oldFileName = getSelectedFileName();//currentFile
      $('#card-' + oldFileName)
        .css('background-color', 'rgb(75, 75, 75')
          .find('a')
            //.css('color', 'rgb(125, 125, 125)')
            .removeClass('card-header-anchor-selected')
            /*.hover(function() {
              $(this).css('color', 'rgb(125, 125, 125)')
            });*/

      $('.collapse').each(function(){
        var thisFileName = $(this)[0].id.replace('cardContent-', '');
        if (thisFileName == fileName) {
          $(this).collapse('show');

          // Style the card to look selected
          $('#card-' + thisFileName)
            .css('background-color', 'rgb(95, 95, 95)')
            .find('a')
              //.css('color', 'rgb(150, 150, 150)')
              .addClass('card-header-anchor-selected');
            
            if (oldFileName != thisFileName && trackInfo[thisFileName] != undefined) {
              fillTrackInfo();

              // Even though the oeprator_code select's value changes, for some reason 
              //  the onchange event isn't fired, so just do so manually
              $('#select-operator_code').change()  
            }
        }
      });

    }


    function loadTracksFromJSON(filePath) {
      // Read the track JSON file and 

      removeAllLayers();


      var fileName = filePath.replace('data/', '').replace('.json', '')
      
      // Initialize objects for this file
      pointGeojsonLayers[fileName] = {};
      lineLayers[fileName] = {};
      lineCoords[fileName] = {};
      colors[fileName] = {};
      minVertexIndices[fileName] = {};
      fileExtents[fileName] = {};
      trackInfo[fileName] = {};  

      var deferred = $.ajax({ // use .ajax() instead of getJSON to set cache=false
        url: filePath,
        dataType: 'json',
        cache: false,
        success: function(data) {
          /* data come in as
          {
            track_info: 
              {
                prop1: val1
                ...
              },
            geojsons: 
              {
                0: geojson_data 
                ...
              }
          }*/
          data['track_info']['visible'] = true;
          // Each item in the JSON file is a separate geojson 
          for (segmentID in data.geojsons) {
            var geojson = data.geojsons[segmentID];
            var firstProperties = geojson.features[0].properties
            data.track_info['departure_datetime'] = firstProperties.departure_datetime
            data.track_info['registration'] = firstProperties.registration
            trackInfo[fileName][segmentID] = data.track_info
            
            var color = getColor();
            colors[fileName][segmentID] = color;
            pointGeojsonLayers[fileName][segmentID] = L.geoJSON(geojson, {
              onEachFeature: ((feature, layer) => onEachPoint(feature, layer, fileName)), 
              pointToLayer: ((feature, latlng) => geojsonPointAsCircle(feature, latlng, color))
            });

          }
        }
      }).done(function() {    
        // Once the async call is done, add all the lines and 
        //  the points for a single line to the map
        var polylineCoords = [];
        for (var segmentID in lineCoords[fileName]) {
          var line = L.polyline(
            lineCoords[fileName][segmentID], 
            options={color: colors[fileName][segmentID]}
            )
          .addTo(map);
          line.on({click: onLineClick});
          lineLayers[fileName][segmentID] = line;
          polylineCoords.push(lineCoords[fileName][segmentID]);
        }

        // Show first line
        if (selectedLines[fileName] == undefined) {
          selectedLines[fileName] = 0;
        }

        var allLines = L.polyline(polylineCoords);
        fileExtents[fileName] = allLines.getBounds();
        showVertices(selectedLines[fileName]);
        //map.fitBounds(fileExtents[fileName]);

        // Add lines to legend
        updateLegend(fileName);

        // Fill in the rest of the track info (from reading the geojsons)
        fillTrackInfo(); 
      })

      return deferred;
    }


    function loadTracksFromMemory(fileName) {
      
      // remove current layers
      removeAllLayers();

      // Add the lines for this file
      for (segmentID in lineLayers[fileName]) {
        lineLayers[fileName][segmentID].addTo(map);
      }

      // show the right file as selected
      //fileWasSelected(fileName);

      // Update the legend
      updateLegend(fileName);

      //show points for the most recently selected segment
      if (selectedLines[fileName] >= 0) {
        showVertices(selectedLines[fileName], hideCurrent=false);
      }

      // zoom to extent
      map.fitBounds(fileExtents[fileName])
    }


    function writeJSON(){

      var fileName = getSelectedFileName();//$('.file-list-row-selected').text()
      var filePath = 'data/edited/' + fileName.replace('_geojsons.json', '.geojson');
      
      // The point layes are in the format {segID: {geojson}} so just combine all of 
      //  the features into a single FeatureCollection GeoJSON object since the 
      //  segment IDs are also recorded in the properties of each feature
      var features = []
      for (segmentID in pointGeojsonLayers[fileName]) {
        var geojson = pointGeojsonLayers[fileName][segmentID].toGeoJSON();
        for (thisID in geojson) {
          features.push(...geojson[thisID]);
        }
      }
      var thisGeojson = {
        type: "FeatureCollection",
        crs: { type: "name", properties: { name: "urn:ogc:def:crs:OGC:1.3:CRS84" } },
        features: features
      }

      // send a post request to the PHP script
      var data = {
        action: "writeFile",
        filePath: filePath,
        jsonString: JSON.stringify(thisGeojson)
      };

      $.ajax({
        url: 'geojson_io.php',
        method: 'POST',
        data: data,
        success: function(response) {
          if (response == false) {
            alert('JSON data failed to save')
          }
        }
      }).fail(alert('JSON data failed to save'));

    }


    function fillTrackInfo(){

      var fileName = getSelectedFileName();
      var thisInfo = trackInfo[fileName][selectedLines[fileName]];

      // If there's no info for the selected track (= -1), get the first 
      //  one because each track for a given file has the same global track info
      if (thisInfo == undefined) {
        for (segmentID in trackInfo[fileName]) {
          // get the first one
          thisInfo = trackInfo[fileName][segmentID];
          break;
        }
      }

      for (key in thisInfo) {
        //console.log(key + ': ' + thisInfo[key])
        $('#textbox-' + key).val(thisInfo[key]);
        $('#p-' + key).text(thisInfo[key])//for the submitter comments
        $('#select-' + key).val(thisInfo[key])//for the select dropdowns
        if (key == 'tracks_mission' || key == 'operator_code') {
          console.log(`${key}: ${thisInfo[key]}`)
          console.log($('#select-' + key).val())}
      }
      //$('#track-info-subtitle').text(`Submitted at ${thisInfo.submission_time}\nby ${thisInfo.submitter}`)
      $('#p-submitted-at').text(`Submitted at ${thisInfo.submission_time}`);
      $('#p-submitted-by').text(`by ${thisInfo.submitter}`);
    }


    function fillSelectOptions(selectElementID, queryString, columnName) {
      
      var deferred = $.ajax({
        url: 'geojson_io.php',
        method: 'POST',
        data: {action: 'query', queryString: queryString},
        cache: false,
        success: function(queryResultString){
          var queryResult = queryResultString.startsWith('ERROR') ? false : $.parseJSON(queryResultString);
          if (queryResult) {
            queryResult.forEach(function(object) {
              $('#' + selectElementID).append(
                `<option class="track-info-option" value="${object.value}">${object.value}</option>`
              );
            })
          } else {
            console.log(`error filling in ${selectElementID}: ${queryResultString}`);
          }
        }
      });
      return deferred;
    }


    function onOperatorChange(target){
      console.log(trackInfo)

      var selectedOperator = $(target).val();
      var selectedMission = $('#select-tracks_mission').val();
      var fileName = getSelectedFileName();

      // Update track info
      if (trackInfo[fileName] !== undefined) {
        for (segmentID in trackInfo[fileName]) {
          trackInfo[fileName][segmentID]['operator_code'] = selectedOperator; //capture value
        }
      }

      // If the operator isn't the NPS, disable mission_code select
      if (selectedOperator !== 'National Park Service') {
        $('#label-tracks_mission').addClass('select-disabled-label');
        // Record the currently selected mission code
        if (trackInfo[fileName] !== undefined) {
          console.log($('#select-tracks_mission'))
          for (segmentID in trackInfo[fileName]) {
            trackInfo[fileName][segmentID]['tracks_mission'] = selectedMission; //capture value
          }
        }
        // Disable it and set the value as null
        $('#select-tracks_mission')
          .addClass('select-disabled')
          .attr('disabled', 'true')
          .val('');
      // If it is NPS, make sure mission_code select is enabled
      } else {
        $('#label-tracks_mission').removeClass('select-disabled-label');
        $('#select-tracks_mission')
          .removeClass('select-disabled')
          .removeAttr('disabled');
        // Set the value to whatever was recorded before disabling
        var thisInfo = trackInfo[fileName];
        if (thisInfo !== undefined) {
          for (segmentID in thisInfo) {
            $('#select-tracks_mission').val(thisInfo[segmentID]['tracks_mission'].length ? thisInfo[segmentID]['tracks_mission'] : '');
            break // just assign with the first one
          }
          
        }
      }
      console.log(trackInfo)
    }


    function lockButtonClick() {

      var lockButton = $('#button-track-info-lock')
      var infoForm = $('#form-track-info')
      if (lockButton.hasClass('unlocked')) {
        lockButton.removeClass('unlocked')
        infoForm.find('input[type="text"]')
          .addClass('locked')
          .attr('disabled', 'true');
        infoForm.find('select')
          .addClass('locked')
          .attr('disabled', 'true');
      } else {
        lockButton.addClass('unlocked');
        infoForm.find('input[type="text"]')
          .removeClass('locked')
          .removeAttr('disabled');
        infoForm.find('select').removeClass('locked')
          .removeClass('locked')
          .removeAttr('disabled');
      }
    }


    function addMapNavToolbar() {
      /* Add a toolbar for zooming to full extent and the extent of the selected track*/

      var zoomSelected = L.Toolbar2.Action.extend({
          options: {
              toolbarIcon: {
                  html: '<img src="imgs/zoom_selected_icon.svg"/>',
                  tooltip: 'Zoom to selected track'
              }
          },
          addHooks: function () {
            var fileName = getSelectedFileName();
            if (fileName !== undefined) {
              map.fitBounds(lineLayers[fileName][selectedLines[fileName]].getBounds());
            } else {
              alert('The map is currently loading. Please wait to zoom until all tracks are loaded.');
            }
          }
            
      });

      var zoomFull = L.Toolbar2.Action.extend({
          options: {
              toolbarIcon: {
                  html: '<img src="imgs/zoom_full_icon.svg"/>',
                  tooltip: 'Zoom to full extent'
              }
          },
          addHooks: function () {
            var fileName = getSelectedFileName();
            if (fileName !== undefined) {
              map.fitBounds(fileExtents[fileName]);
            } else {
              alert('The map is currently loading. Please wait to zoom until all tracks are loaded.');
            }
          }
      });

      new L.Toolbar2.Control({
          actions: [zoomSelected, zoomFull],
          position: 'topleft'
      }).addTo(map);
    }

    //var startPoint = [63.1249, -149.254];
    var map = L.map('map', {editable: true})//.setView(startPoint, 10)
    var tilelayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
      attribution: 'Tiles &copy; Esri &mdash; Source: Esri, DeLorme, 2019'
    }).addTo(map);
    
    map.doubleClickZoom.disable();
    
    var pointGeojsonLayers = {};
    var lineLayers = {};
    var lineCoords = {};
    var colors = {};
    var minVertexIndices = {};
    var trackInfo = {};
    var selectedLines = {};
    var fileExtents = {};
    
    // Make sure files are read from disk every time
    $(document).ready(function() {
      $.ajaxSetup({ cache: false });
      $('#map-container').css('height', $(window).height());
      //$('#menu-container').css('height', $('#map').height() + $('#save-button').height() + 10);

    });

    $.ajax({
      url: 'geojson_io.php',
      method: 'POST',
      data: {action: "getFiles"},
      cache: false,
      success: function(json_string) {
        var files = $.parseJSON(json_string);
        files.forEach(function(filePath) {
          addFileToMenu(filePath);
        })

        fileWasSelected(files[0].replace('data/', '').replace('.json', ''))
        var deferred = loadTracksFromJSON(files[0]) // load any file, doesn't matter which
        
        // When the tracks have finished loading, get track info
        deferred.done(function() {
          $.ajax({
            url: 'geojson_io.php',
            method: 'POST',
            data: {action: 'getUser'},
            cache: false,
            success: function(username){
              // If authentication failed, do nothing
              if (username) {
                $('#textbox-track_editor').val(username);
              }
            }
          })

          // Add map navigation toolbar. Must be added after tracks are 
          //  loaded because the map view has to be set first
          addMapNavToolbar();
        })
      }

    });

    var deleteEvent = document.addEventListener('keydown', onKeyDown);
    map.addEventListener('click', onMapClick);// {
    //$('#save-button').click(writeJSON);
    
    // Add options to the select elements. 
    $.when(
      fillSelectOptions('select-operator_code', "SELECT name AS value FROM operators ORDER BY sort_order;"),
      fillSelectOptions('select-tracks_mission', "SELECT code AS value FROM nps_mission_codes ORDER BY code;")
    ).then(function() {
      fillTrackInfo() // Fill track info here because select options weren't available to fill before
      $('#select-operator_code').change() // disable the mission code select if necessary after track info is filled in 
    }) 


    $('#select-operator_code').change(function() {onOperatorChange(this)})

    $('#select-tracks_mission').click(function() {
      var fileName = getSelectedFileName();
      if (trackInfo[fileName]) {
        console.log($(this.val))
        for (segmentID in trackInfo[fileName]) {
          trackInfo[fileName][segmentID]['tracks_mission'] = $(this).val();
        }
      }
    })
    
  </script>
</body>
</html>
