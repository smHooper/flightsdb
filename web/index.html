<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width,height=device-height, user-scalable=no" />
  <title>Overflight data</title>
  <link rel="stylesheet" href="https://npmcdn.com/leaflet@1.2.0/dist/leaflet.css" />
  <script src="./node_modules/leaflet/dist/leaflet.js"></script>
  <script src="./node_modules/leaflet-filelayer/src/leaflet.filelayer.js"></script>
  <script src="./js/leaflet-providers.js"></script>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <!--<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"/>
  <script src="./Leaflet.Editable/src/Leaflet.Editable.js"></script>-->
  <style type='text/css'>
      body { 
        height: 100%; 
        width: 100%; 
        background-color: rgb(50, 50, 50);
      }
      

      #menu-container {
        position: relative;
        border: 5px;
        border-color: rgb(100, 100, 100);
      }
      
      #map { 
        position: relative; 
        height: 800px; */
        margin-bottom: 0;
        margin-top: 0;
        width:100%;
      }

      .file-list-row {
        height: 50px;
        border: 2px solid rgb(100, 100, 100);
        color: rgb(110, 110, 110);
      }

      .file-list-row:hover {
        font-weight: bold;
        border: 3px solid rgb(100, 100, 100);
        cursor: pointer;
      }

      .file-list-row-selected {
        height: 50px;
        border: 4px solid rgb(100, 100, 100);
        font-weight: bold;
        color: rgb(125, 125, 125);
        background-color: rgb(75, 75, 75);
        box-shadow: 8px 16px 16px 0 rgba(0,0,0,0.3)
      }

      .file-list-row-selected:hover {
        cursor: auto;
        border: 4px solid rgb(100, 100, 100);
      }

      #dashboard-container {
        padding: 20;
      }

      .data-button {
        height: 50px;
        width: 150px;
        top: 10px;
        position: relative;
        /*padding: 14px 28px;*/
        font-size: 16px;
        background-color: rgb(125, 125, 125);
        color: rgb(200, 200, 200);
        border: none;
        display: inline-block;
      }

      td {
        color: rgb(100, 100, 100);
        text-align: center;
      }

      .dark-scrollbar {
        overflow-y: auto;
      }
      .dark-scrollbar::-webkit-scrollbar-track {
          background-color: rgb(60, 60, 60);
      }
      .dark-scrollbar::-webkit-scrollbar-thumb {
          background-color: rgb(110, 110, 110);
      }


  </style>
</head>

<body>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
  <div id="dashboard-container" class="container-fluid">
    
    <div class="row">
      
      <div id='menu-container' class="col-sm-3">
        <div>
          <h3 style="color: rgb(110, 110, 110);">Files to import</h3>
          <div class="dark-scrollbar">
            <table id='files-table' style="width: 100%; max-height: 30%; background-color: rgb(60, 60, 60)">
              <!-- rows added dynamically in js -->
            </table>
          </div>
        </div>
        <div style="overflow-y: auto;">
          <table id='legend' style="width: 100%; background-color: rgb(60, 60, 60)">
            <!-- rows added dynamically in js -->
          </table>
        </div>
      </div>
      
      <div id='map-container' class="col-sm-9">
        <div id='map'></div>

        <div class="row" style="top: 10px;">
          <div class="col-sm-2">
            <button class="button data-button" id="save-button">Save tracks</button>
          </div>
          <div class="col-sm-2">
            <button class="button data-button" id="save-button">Import data</button>
          </div>          

        </div>
      </div>
    
    </div>

  </div>

  <script type="text/javascript">


    function getColor() {
      var color = Math.floor(Math.random() * 16777216).toString(16);
      var hexColor = '#000000'.slice(0, -color.length) + color;

      return hexColor;
    }


    function splitAtVertex(segmentID, vertexID, minVertexIndex){
      /*
      Split a line at the associated vertex. vertexID is the ID of the 
      point from the geojson used to create it
      */

      var originalLine = lineLayers[segmentID];
      var allLatlngs = originalLine.getLatLngs();

      // vertexID is a global ID so calculate the index within the latlngs array
      var vertexIndex = vertexID - minVertexIndex 

      var originalLatlngs = allLatlngs.slice(0, (vertexIndex + 1));
      var newLatLngs = allLatlngs.slice(vertexIndex);
      
      // Set coords for the old line (everything up to the vertex) and 
      //  create the new line (the new vertex and everything after)
      originalLine.setLatLngs(originalLatlngs);
      var newSegmentID = Math.max.apply(null, Object.keys(lineLayers)) + 1;
      var newColor = getColor();
      colors[newSegmentID] = newColor;
      var newLine = L.polyline(
        newLatLngs, 
        options={color: newColor})
      .addEventListener({click: onLineClick})
      .addTo(map);
      lineLayers[newSegmentID] = newLine;

      // Create the new point geojson by looping through all points 
      //  of the original and adding each .feature to the json
      var newGeoJSON = {
        type: "FeatureCollection",
        features: []
      }
      pointGeojsonLayers[segmentID].eachLayer(
        function(layer) {
          var featureID = layer.feature.id;
          var theseCordinates = layer.feature.geometry.coordinates
          var theseProperties = layer.feature.properties
          // only add this point if it occurs after the splitting vertex
          //  (or if it is that vertex)
          if (featureID >= vertexID) {
            // set the mapID to the new segment ID so the points 
            //  are still related to the line
            theseProperties.mapID = newSegmentID;
            theseProperties.min_index = vertexID;
            // add this feature
            newGeoJSON.features.push(layer.feature);

            // if this feature isn't the splitting vertex, 
            //  drop it from the original point layer
            if (featureID > vertexID) {
              pointGeojsonLayers[segmentID].removeLayer(layer)
            };
          }
        }
      )
      pointGeojsonLayers[newSegmentID] = L.geoJSON(newGeoJSON, {
        //**** this doesn't work for some reason (i.e., onEachPoint is never called) *** 
        onEachFeature: onEachPoint, 
        pointToLayer: ((feature, latlng) => geojsonPointAsCircle(feature, latlng, newColor))
      });//.addTo(map);

    }


    function onPointClick(event, segmentID, vertexID, minVertexIndex) {
      if (event.originalEvent.ctrlKey) {
        splitAtVertex(segmentID, vertexID, minVertexIndex)
      }
    }

    var trackInfo = {}

    function onEachPoint(feature, layer) {
      /*
      For each point, add the coordinates to a dictionary of 
      segmentID: [coords] so lines can be created later  
      */
      var properties = feature.properties
      var segmentID = properties.segment_id;
      
      // mapID is used to keep track of lines and points on the map. 
      //  They could be split, which would make the mapID different 
      //  from the segment_id. If the mapID is already set though, 
      //  that means that this feature was created by splitAtVertex(), 
      //  so don't reassign it
      if (feature.properties["mapID"] == undefined) {
        feature.properties["mapID"] = segmentID;
      }
      
      layer.addEventListener({
        click: (e => onPointClick(e, properties.mapID, properties.point_index, properties.min_index))
      });

      // Add coordinates to dict of coordinate arrays for creating lines later
      var pointCoords = feature.geometry.coordinates;
      if (lineCoords[segmentID] === undefined) {
        // coords in geojson are [x, y] but polyline needs [lat, lon]
        lineCoords[segmentID] = [[pointCoords[1], pointCoords[0]]]
      } else {
        lineCoords[segmentID].push([pointCoords[1], pointCoords[0]])
      }

    }


    function showVertices(id) {

      if (currentLineID >= 0) {
        hideVertices(currentLineID);
      }
      
      var geojsonPoints = pointGeojsonLayers[id];
      map.addLayer(geojsonPoints);
      map.fitBounds(geojsonPoints.getBounds());
      lineLayers[id].bringToFront();
      geojsonPoints.bringToFront();

      currentLineID = id;
    }


    function hideVertices(id) {
        map.removeLayer(pointGeojsonLayers[id]);   
    }


    function getLineID(layer) {
      for (var segmentID in lineLayers) {
        if (lineLayers[segmentID] == layer) {
          return segmentID;
        }
      }
    }


    function onLineClick(e) {
      /*
      When a line is clicked, hide the vertices of the active 
      line and show this line's vertices
      */
      //e.orignalEvent.ctrlKey
      if (!e.originalEvent.ctrlKey) {
        var thisLineID = getLineID(e.target);

        showVertices(thisLineID);
        
        L.DomEvent.stop(e) // don't propagate to the map
      }
    }


    function deleteCurrentTrack() {
      /*
      Remove the currently selected line and points from the 
      map and delete references to them
      */
      // remove from the map
      if (currentLineID >= 0 && confirm("Are you sure you want to delete the select track?")) {
        map.removeLayer(pointGeojsonLayers[currentLineID]);
        map.removeLayer(lineLayers[currentLineID]);
        delete pointGeojsonLayers[currentLineID];
        delete lineLayers[currentLineID];
        currentLineID = -1;
      } else {
        alert("No track currently selected. Click a track first then press 'Delete'")
      }
      
    }


    function onKeyDown(e) {

      if (e.key === 'Delete') {
        deleteCurrentTrack();
      }
    }


    function geojsonPointAsCircle(feature, latlng, color) {
      var markerOptions = {
        radius: 8,
        weight: 1,
        opacity: 1,
        fillOpacity: 0.8,
        fillColor: color,
        color: color
      }
      return L.circleMarker(latlng, markerOptions);
    }

    var currentLineID = 0;
    

    function onMapClick(e) {
      /*
      If the map is clicked (not a polyline layer), deselect the current layer
      */

      if (currentLineID >= 0 && !e.originalEvent.ctrlKey) {
        hideVertices(currentLineID);
        currentLineID = -1;
      }
    }


    function addFileToMenu(fileName) {
       
       $('<tr><td class="file-list-row">' + fileName.replace('data/', '') + '</td></tr>')
       .appendTo('#files-table')
       .on('click', function() {
        if (!$(this).children().hasClass('file-list-row-selected')){
          loadTracks(fileName);
        }
       });

    }


    function loadTracks(filePath) {
      // Read the track JSON file and 

      // remove all layers from the map
      map.eachLayer( function(layer) {
        if (!(layer instanceof L.TileLayer)) {
          map.removeLayer(layer)
        }
      })
      pointGeojsonLayers = {};
      lineLayers = {};
      lineCoords = {};
      colors = {};
      minVertexIndices = {};

      $.getJSON(
        filePath,
        function(data) {
          // Each item in the JSON file is a separate geojson 
          for (var segmentID in data) {
            var geojson = data[segmentID];//$.parseJSON(data[segmentID]);
            var color = getColor();
            colors[segmentID] = color;
            pointGeojsonLayers[segmentID] = L.geoJSON(geojson, {
              onEachFeature: onEachPoint, 
              pointToLayer: ((feature, latlng) => geojsonPointAsCircle(feature, latlng, color))
            });
          }
        }
      ).done(function() {    
        // Once the async call is done, add all the lines and 
        //  the points for a single line to the map
        var polylineCoords = [];
        var fileName = filePath.replace('data/', '')
        for (var segmentID in lineCoords) {
          var line = L.polyline(lineCoords[segmentID], options={color: colors[segmentID]}).addTo(map);
          line.on({click: onLineClick});
          lineLayers[segmentID] = line;
          polylineCoords.push(lineCoords[segmentID]);
           
          // Add info for the legend if it hasn't already been added
          var thisInfo = pointGeojsonLayers[segmentID].toGeoJSON().features[0].properties;
          thisInfo['visible'] = true;

          if (trackInfo[fileName] == undefined) {
              trackInfo[fileName] = {segmentID: thisInfo}
          } else if (trackInfo[fileName][segmentID] == undefined) {
            trackInfo[fileName][segmentID] = thisInfo;
          }
        }

        console.log(trackInfo)

        currentLineID = 0;
        showVertices(currentLineID);
        var allLines = L.polyline(polylineCoords);
        map.fitBounds(allLines.getBounds());
      })

      // remove selection if this is not the currently selected file.
      //  otherwise, add .selected style
      $('.file-list-row-selected')
        .removeClass('file-list-row-selected')
        .addClass('file-list-row');
      $('.file-list-row').each(function(){
        if ($(this).text() == filePath.replace('data/', '')) {
          $(this).addClass('file-list-row-selected');
        }
      });


    }


    function writeJSON(){

      var filePath = 'data/edited/' + $('.file-list-row-selected').text().replace('_geojsons.json', '.geojson');
      
      // The point layes are in the format {segID: {geojson}} so just combine all of 
      //  the features into a single FeatureCollection GeoJSON object since the 
      //  segment IDs are also recorded in the properties of each feature
      var features = []
      for (segmentID in pointGeojsonLayers) {
        var geojson = pointGeojsonLayers[segmentID].toGeoJSON();
        for(thisID in geojson) {
          features.push(...geojson[thisID]);
        }
      }
      var thisGeojson = {
        type: "FeatureCollection",
        crs: { type: "name", properties: { name: "urn:ogc:def:crs:OGC:1.3:CRS84" } },
        features: features
      }

      // send a post request to the PHP script
      var data = {
        action: "writeFile",
        filePath: filePath,
        jsonString: JSON.stringify(thisGeojson)
      };

      $.ajax({
        url: 'geojson_io.php',
        method: 'POST',
        data: data,
        success: function(response) {
          if (response == false) {
            alert('JSON data failed to save')
          }
        }
      }).fail(alert('JSON data failed to save'));

    }

    //var startPoint = [63.1249, -149.254];
    var map = L.map('map', {editable: true})//.setView(startPoint, 10)
    var tilelayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
      attribution: 'Tiles &copy; Esri &mdash; Source: Esri, DeLorme, 2019'
    }).addTo(map);
    
    map.doubleClickZoom.disable();
    
    var pointGeojsonLayers = {};
    var lineLayers = {};
    var lineCoords = {};
    var colors = {};
    var minVertexIndices = {};

    $.ajax({
      url: 'geojson_io.php',
      method: 'POST',
      data: {action: "getFiles"},
      success: function(json_string) {
        var files = $.parseJSON(json_string);
        files.forEach(function(filePath) {
          addFileToMenu(filePath);
        })
        loadTracks(files[0]) // load any file, doesn't matter which
      }
    });

    var deleteEvent = document.addEventListener('keydown', onKeyDown);
    map.addEventListener('click', onMapClick);// {
    $('#save-button').click(writeJSON);

    
  </script>
</body>
</html>
