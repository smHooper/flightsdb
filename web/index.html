<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width,height=device-height, user-scalable=no" />
  <title>Overflight data</title>
  <link rel="stylesheet" href="https://npmcdn.com/leaflet@1.2.0/dist/leaflet.css" />
  <script src="./node_modules/leaflet/dist/leaflet.js"></script>
  <script src="./node_modules/leaflet-filelayer/src/leaflet.filelayer.js"></script>
  <script src="./js/leaflet-providers.js"></script>
  <!--<script src="./Leaflet.Editable/src/Leaflet.Editable.js"></script>-->
  <style type='text/css'>
      body { margin:0; padding:0; }
      #map { position:absolute; top:0; bottom:0; right: 0; left: 20%; width:80%; }
</style>
</head>
<body>
  <!--<script src='https://api.mapbox.com/mapbox.js/plugins/leaflet-omnivore/v0.2.0/leaflet-omnivore.min.js'></script> -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
  <div id='map'></div>

  <script type="text/javascript">
    //var startPoint = [63.1249, -149.254];
    var map = L.map('map', {editable: true})//.setView(startPoint, 10)
    var tilelayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
    	attribution: 'Tiles &copy; Esri &mdash; Source: Esri, DeLorme, 2019'
    }).addTo(map);
    
    map.doubleClickZoom.disable();
    
    var pointGeojsonLayers = [];
    var lineLayers = {};
    var lineCoords = {};
    var colors = {};
    var minVertexIndices = {};

    // keep track of line IDs so that when a new line is created (on split), 
    //  it can be given a new ID not found in the original geojson and but 
    //  the import process still knows what line it corresponds to
    var originalLineIDs = {}


    function getColor() {
      var color = Math.floor(Math.random() * 16777216).toString(16);
      var hexColor = '#000000'.slice(0, -color.length) + color;

      return hexColor;
    }


    function splitAtVertex(segmentID, vertexID, minVertexIndex){
      /*
      Split a line at the associated vertex. vertexID is the ID of the 
      point from the geojson used to create it
      */

      var originalLine = lineLayers[segmentID];
      var allLatlngs = originalLine.getLatLngs();

      // vertexID is a global ID so calculate the index within the latlngs array
      var vertexIndex = vertexID - minVertexIndex 

      var originalLatlngs = allLatlngs.slice(0, (vertexIndex + 1));
      var newLatLngs = allLatlngs.slice(vertexIndex);
      
      console.log("segmentID: " + segmentID);
      console.log("vertexID: " + vertexID);
      console.log("minVertexIndex: " + minVertexIndex);
      console.log("vertexIndex: " + vertexIndex);
      // Set coords for the old line (everything up to the vertex) and 
      //  create the new line (the new vertex and everything after)
      originalLine.setLatLngs(originalLatlngs);
      var newSegmentID = Math.max.apply(null, Object.keys(lineLayers)) + 1;
      var newColor = getColor();
      colors[newSegmentID] = newColor;
      var newLine = L.polyline(
        newLatLngs, 
        options={color: newColor})
      .clearAllEventListeners()
      .addEventListener({click: showVertices})
      .addTo(map);
      lineLayers[newSegmentID] = newLine;
      console.log("lineLayer keys: " + Object.keys(lineLayers));

      // Create the new point geojson by looping through all points 
      //  of the original and adding each .feature to the json
      var newGeoJSON = {
        type: "FeatureCollection",
        features: []
      }
      pointGeojsonLayers[segmentID].eachLayer(
        function(layer) {
          var featureID = layer.feature.id;
          var theseCordinates = layer.feature.geometry.coordinates
          var theseProperties = layer.feature.properties
          // only add this point if it occurs after the splitting vertex
          //  (or if it is that vertex)
          if (featureID >= vertexID) {
            // set the mapID to the new segment ID so the points 
            //  are still related to the line
            theseProperties.mapID = newSegmentID;
            theseProperties.min_index = vertexID;
            // add this feature
            newGeoJSON.features.push(layer.feature);

            // if this feature isn't the splitting vertex, 
            //  drop it from the original point layer
            if (featureID > vertexID) {
              pointGeojsonLayers[segmentID].removeLayer(layer)
            };
          }
        }
      )
      pointGeojsonLayers[newSegmentID] = L.geoJSON(newGeoJSON, {
        //**** this doesn't work for some reason (i.e., onEachPoint is never called) *** 
        onEachFeature: onEachPoint, 
        pointToLayer: ((feature, latlng) => geojsonPointAsCircle(feature, latlng, newColor))
      });//.addTo(map);
      console.log("point layer keys: " + Object.keys(pointGeojsonLayers));
    }


    function onEachPoint(feature, layer) {
      /*
      For each point, add the coordinates to a dictionary of 
      segmentID: [coords] so lines can be created later  
      */
      var properties = feature.properties
      var seg_id = properties.segment_id;
      
      // mapID is used to keep track of lines and points on the map. 
      //  They could be split, which would make the mapID different 
      //  from the segment_id. If the mapID is already set though, 
      //  that means that this feature was created by splitAtVertex(), 
      //  so don't reassign it
      if (feature.properties["mapID"] == undefined) {
        feature.properties["mapID"] = seg_id;
      }
      
      layer.on({dblclick: (e => splitAtVertex(properties.mapID, properties.point_index, properties.min_index))});

      // Add coordinates to dict of coordinate arrays for creating lines later
      var pointCoords = feature.geometry.coordinates;
      if (lineCoords[seg_id] === undefined) {
        // coords in geojson are [x, y] but polyline needs [lat, lon]
        lineCoords[seg_id] = [[pointCoords[1], pointCoords[0]]]
      } else {
        lineCoords[seg_id].push([pointCoords[1], pointCoords[0]])
      }
    }


    function showLayer(id) {
      var geojsonPoints = pointGeojsonLayers[id];
      map.addLayer(geojsonPoints);
      map.fitBounds(geojsonPoints.getBounds());
      lineLayers[id].bringToFront();
      geojsonPoints.bringToFront();
    }


    function hideLayer(id) {
        map.removeLayer(pointGeojsonLayers[id]);   
    }


    function getLineID(layer) {
      console.log(pointGeojsonLayers)
      for (var segmentID in lineLayers) {
        if (lineLayers[segmentID] == layer) {

          return segmentID;
        }
      }
    }


    function showVertices(e) {
      /*
      When a line is clicked, hide the vertices of the active 
      line and show this line's vertices
      */
      console.log("line double clck")
      var thisLineID = getLineID(e.target);
      hideLayer(currentLineID);
      showLayer(thisLineID);
      currentLineID = thisLineID;
    }

    function geojsonPointAsCircle(feature, latlng, color) {
      var markerOptions = {
        radius: 8,
        weight: 1,
        opacity: 1,
        fillOpacity: 0.8,
        fillColor: color,
        color: color
      }
      return L.circleMarker(latlng, markerOptions);
    }

    var currentLineID = 0;
    

    var deferred = $.getJSON("data/201961_616tail09_geojsons.json",
      function(data) {
        // Each item in the JSON file is a separate geojson 
        for (var segmentID in data) {
          var geojson = data[segmentID];//$.parseJSON(data[segmentID]);
          var color = getColor();
          colors[segmentID] = color;
          pointGeojsonLayers[segmentID] = L.geoJSON(geojson, {
            onEachFeature: onEachPoint, 
            pointToLayer: ((feature, latlng) => geojsonPointAsCircle(feature, latlng, color))
          });
        }
      }
    ).done(function() {    
      // Once the async call is done, add all the lines and 
      //  the points for a single line to the map
      for (var seg_id in lineCoords) {
        var line = L.polyline(lineCoords[seg_id], options={color: colors[seg_id]}).addTo(map);
        line.on({click: showVertices});
        lineLayers[seg_id] = line;
        originalLineIDs[seg_id] = seg_id
        polylineCoords.push(lineCoords.seg_id);
      }
      currentLineID = 0;
      showLayer(currentLineID);
      
    });

    
  </script>
</body>
</html>
