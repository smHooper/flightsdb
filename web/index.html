<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width,height=device-height, user-scalable=no" />
  <title>Overflight editor</title>
  <link rel="stylesheet" href="https://npmcdn.com/leaflet@1.2.0/dist/leaflet.css" />
  <script src="./node_modules/leaflet/dist/leaflet.js"></script>
  <script src="./node_modules/leaflet-filelayer/src/leaflet.filelayer.js"></script>
  <script src="./js/leaflet-providers.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
  <link href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" rel="stylesheet" id="bootstrap-css">
  <script src="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"></script>

  <style type='text/css'>
      body { 
        height: 100%; 
        width: 100%; 
        background-color: rgb(50, 50, 50);
      }
      

      #menu-container {
        position: relative;
        border: 5px;
        border-color: rgb(100, 100, 100);
      }
      
      /*#map { 
        position: relative; 
        min-height: 650px;
        margin-bottom: 0;
        margin-top: 0;
        width: 100%;
      }*/

      .leaflet-popup-content-wrapper {
        background-color: rgb(85, 85, 85);
        color: rgb(145, 145, 145);
      }
      .leaflet-popup-tip {
        background-color: rgb(85, 85, 85);
      }
      .leaflet-popup-content p{
        margin: 3px;
      }
      /*.card-header {
        background-color: rgb(60, 60, 60);
        border-bottom:  
      }*/
      .card {
        /*height: 60px;*/
        /*border: 2px solid rgb(100, 100, 100);*/
        color: rgb(125, 125, 125);
        background-color: rgb(75, 75, 75);

      }

      .card-header a{
        transition: 0.3s;
        color: rgb(125, 125, 125);
      }

      .card-header a:hover {
        /*font-weight: bold;*/
        color: rgb(150, 150, 150);
        cursor: pointer;
      }

      .card-header-anchor-selected {
        color: rgb(150, 150, 150);
      }

      .card-header a.card-header-anchor-selected{
        transition: 0.3s;
        color: hsl(38, 85%, 40%);
      }

      .show {
        max-height: 20%;
        /*border: 4px solid rgb(100, 100, 100);*/
        /*font-weight: bold;*/
        color: rgb(125, 125, 125);
        background-color: rgb(60, 60, 60);
        /*box-shadow: 0px 16px 16px 0 rgba(0,0,0,0.2);*/
        text-align: center;
      }

      .card-footer {
        height: 30px;
        background-color: rgb(60, 60, 60);
      }
      /*.show:hover {
        cursor: auto;
        border: 4px solid rgb(100, 100, 100);
      }*/

      .legend-row {
        height: 50px;
        width: 100%;
      }
      
      .legend-row:hover {
        color: rgb(120, 120, 120);
        background-color: rgb(65, 65, 70);
        cursor: pointer;
      }

      .legend-row-selected {
        height: 50px;
        background-color: rgb(80, 80, 90);
        cursor: auto;
      }

      .legend-cell {
        color: rgb(110, 110, 110);
        text-align: center;
        display: inline-block;
        vertical-align: center;
        padding-top: 12px;
        transition: 0.2s;
      }

      .legend-cell:hover {
        color: rgb(120, 120, 120);
      }

      .legend-cell-selected {
        color: rgb(130, 130, 130);
        text-align: center;
        display: inline-block;
        vertical-align: center;
        padding-top: 12px;
      }
      
      #dashboard-container {
        padding: 20;
      }

      .data-button {
        height: 50px;
        width: 150px;
        top: 10px;
        position: relative;
        /*padding: 14px 28px;*/
        font-size: 16px;
        background-color: rgb(125, 125, 125);
        color: rgb(200, 200, 200);
        border: none;
        display: inline-block;
        transition: 0.4s;
      }

      .data-button:hover {
        background-color: hsl(38, 60%, 40%);
        /*color: hsl(38, 95%, 45%);*/
      }

      td {
        color: rgb(100, 100, 100);
        text-align: center;
      }

      .dark-scrollbar {
        overflow-y: auto;
      }
      .dark-scrollbar::-webkit-scrollbar-track {
          background-color: rgb(60, 60, 60);
      }
      .dark-scrollbar::-webkit-scrollbar-thumb {
          background-color: rgb(110, 110, 110);
      }


      /* Custom checkbox*/
      /* The container */
      .checkmark-container {
        display: block;
        position: relative;
        cursor: pointer;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }

      /* Hide the browser's default checkbox */
      .checkmark-container input {
        position: absolute;
        opacity: 0;
        cursor: pointer;
        height: 0;
        width: 0;
      }

      /* Create a custom checkbox */
      .checkmark {
        position: absolute;
        top: 0;
        left: 0;
        height: 20px;
        width: 20px;
        background-color: none;
        border: 2px solid rgb(90, 90, 90);
        vertical-align: center;
        horizontal-align: center;
      }

      /*When the checkbox is checked, make the background lighter*/ 
      .checkmark-container input:checked ~ .checkmark {
        background-color: rgb(100, 100, 100);
        border: none;
      }

      /* Create the checkmark/indicator (hidden when not checked) */
      .checkmark:after {
        content: "";
        position: absolute;
        /*display: none;*/
        opacity: 0;
      }

      /* Show the checkmark when checked */
      .checkmark-container input:checked ~ .checkmark:after {
        /*display: block;*/
        opacity: 1;
      }

      /* Style the checkmark/indicator */
      .checkmark-container .checkmark:after {
        left: 7px;
        top: 2px;
        width: 7px;
        height: 12px;
        border: solid rgb(180, 180, 180);
        border-width: 0 2px 2px 0;
        -webkit-transform: rotate(45deg);
        -ms-transform: rotate(45deg);
        transform: rotate(45deg);
        vertical-align: center;
      }

      /* Track info form*/
      input {
        box-sizing: border-box;

      }
      .track-info-label {
        color: rgb(125, 125, 125);
        display: block;
        margin-bottom: 10px;
      }
      .track-info-textbox {
        color: rgb(135, 135, 135);
        background-color: rgb(75, 75, 75);
        border: none;
        display: block;
        width: 100%;
        min-width: 80px;
        height: 40px;
        padding-left: 7px;
      }

      input[type="text"]:focus {
        -webkit-box-shadow: none;
        outline: -webkit-focus-ring-color auto 0px;
        border: solid 1.5px hsl(38, 85%, 30%);
      }
      .input-container {
        display: inline-block; 
        width: 50%; 
        padding: 15px;
      }

  </style>
</head>

<body>

  <div id="dashboard-container" class="container-fluid" style="display:flex;">
    
    <div class="row h-100" style="display: flex; width:100%">
      
      <div id='menu-container' class="col-sm-6 col-md-8 col-lg-4" style="display: flex; flex-direction: column;">
        <div>
          <!-- File menu and legend-->
          <h4 style="color: rgb(110, 110, 110);">Files to import</h4>
          <div style="min-height:65%; overflow:auto; align-items:stretch;" >
            <div class='accordion' id='file-list'>
              <!--items added dynamically on load -->
            </div>
          </div>
        </div>

        <div class="dark-scrollbar" id="track-info-panel" style="width:100%; min-height:20%; background-color: rgb(60, 60, 60); padding: 20px;">
          <!-- Info about each track-->
          <div style="display:flex;">
            <div style="color: rgb(110, 110, 110); display:inline-block;">
              <h4 style="color: inherit;">Track info</h4>
              <!--<p id="track-info-subtitle" style="color: inherit; font-size:14px;"></p>
              -->
              <p id="p-submitted-at" style="color: inherit; font-size:14px; padding: 0px; margin-bottom:4px;"></p>
              <p id="p-submitted-by" style="color: inherit; font-size:14px; padding: 0px;"></p>
            </div>
          </div>
          <form style="width: 100%; position: relative;">

            <div class="row" style="display: flex;">
              <div class="input-container">
                <label class="track-info-label">Submitter</label>
                <input type="text" class="track-info-textbox" id="textbox-submitter" name="submitter" spellcheck="false">
              </div>
              <div class="input-container">
                <label class="track-info-label">Time submitted</label>
                <input type="text" class="track-info-textbox" id="textbox-submission_time" name="submission_time" spellcheck="false">
              </div>
            </div>

            <div class="row" style="display: flex;">
              <div class="input-container">
                <label class="track-info-label">Tail number</label>
                <input type="text" class="track-info-textbox" id="textbox-registration" name="registration" spellcheck="false">
              </div>
              <div class="input-container">
                <label class="track-info-label">Editor</label>
                <input type="text" class="track-info-textbox" id="textbox-track_editor" name="editor" spellcheck="false">
              </div>
            </div>

            <div class="row" style="display: flex;">
              <div class="input-container" style="width:100%">
                <label class="track-info-label">Submitter notes</label>
                <div class="track-info-textbox" style="height:80px; overflow-y:auto; background-color: rgb(65, 65, 65); color(115, 115, 115);">
                  <p id="p-submitter_notes" style="width:100%"></p>
                </div>
              </div>
            </div>

          </form>
        </div>
      </div>
      
      <div id='map-container' class="col-sm-6 col-md-8 col-lg-8" style="display: inline-block;">
        <div id='map'style="position: relative; min-height: 650px; margin-bottom: 0; margin-top: 0; width: 100%; height:90%;">
        </div>

        <div class="row" style="top: 10px;">
          <div class="col-sm-2">
            <button class="button data-button" id="save-button">Save tracks</button>
          </div>

          <div class="col-sm-2">
            <!--<button class="button data-button" id="save-button">Import data</button>-->
          </div>          
        </div>
      </div>
    
    </div>

  </div>

  <script type="text/javascript">


    function getColor() {
      var color = Math.floor(Math.random() * 16777216).toString(16);
      var hexColor = '#000000'.slice(0, -color.length) + color;

      return hexColor;
    }


    function getSelectedFileName() {
      return $('.card-header-anchor-selected.card-link.text-center > .card-title').text();
    }


    function splitAtVertex(segmentID, vertexID, minVertexIndex){
      /*
      Split a line at the associated vertex. vertexID is the ID of the 
      point from the geojson used to create it
      */

      var fileName = getSelectedFileName();//$('.collapse.show').text();
      var originalLine = lineLayers[fileName][segmentID];
      var allLatlngs = originalLine.getLatLngs();

      // vertexID is a global ID so calculate the index within the latlngs array
      var vertexIndex = vertexID - minVertexIndex 

      var originalLatlngs = allLatlngs.slice(0, (vertexIndex + 1));
      var newLatLngs = allLatlngs.slice(vertexIndex);
      
      // Set coords for the old line (everything up to the vertex) and 
      //  create the new line (the new vertex and everything after)
      originalLine.setLatLngs(originalLatlngs);
      var newSegmentID = Math.max.apply(null, Object.keys(lineLayers[fileName])) + 1;
      var newColor = getColor();
      colors[fileName][newSegmentID] = newColor;
      var newLine = L.polyline(
        newLatLngs, 
        options={color: newColor})
      .addEventListener({click: onLineClick})
      .addTo(map);
      lineLayers[fileName][newSegmentID] = newLine;

      // Create the new point geojson by looping through all points 
      //  of the original and adding each .feature to the json
      var newDepartureTime = pointGeojsonLayers[fileName][segmentID].toGeoJSON().features[vertexIndex].properties.ak_datetime
      var newGeoJSON = {
        type: "FeatureCollection",
        features: []
      }
      pointGeojsonLayers[fileName][segmentID].eachLayer(
        function(layer) {
          var featureID = layer.feature.id;
          var theseCordinates = layer.feature.geometry.coordinates
          var theseProperties = layer.feature.properties
          // only add this point if it occurs after the splitting vertex
          //  (or if it is that vertex)
          if (featureID >= vertexID) {
            // set the mapID to the new segment ID so the points 
            //  are still related to the line
            theseProperties.mapID = newSegmentID;
            theseProperties.min_index = vertexID;
            layer.feature.properties.departure_datetime = newDepartureTime;
            // add this feature
            newGeoJSON.features.push(layer.feature);

            // if this feature isn't the splitting vertex, 
            //  drop it from the original point layer
            if (featureID > vertexID) {
              pointGeojsonLayers[fileName][segmentID].removeLayer(layer)
            };
          }
        }
      )
      pointGeojsonLayers[fileName][newSegmentID] = L.geoJSON(newGeoJSON, { 
        onEachFeature: ((feature, layer) => onEachPoint(feature, layer, fileName)), 
        pointToLayer: ((feature, latlng) => geojsonPointAsCircle(feature, latlng, newColor))
      });

      // Update the legend
      var thisInfo = newGeoJSON.features[0].properties;
      thisInfo['visible'] = true;
      trackInfo[fileName][newSegmentID] = thisInfo;
      showVertices(newSegmentID);
      updateLegend(fileName);
    }


    function onPointClick(event, segmentID, vertexID, minVertexIndex) {
      if (event.originalEvent.ctrlKey) {
        splitAtVertex(segmentID, vertexID, minVertexIndex)
      }
    }


    function onEachPoint(feature, layer, fileName) {
      /*
      For each point, add the coordinates to a dictionary of 
      segmentID: [coords] so lines can be created later  
      */
      var properties = feature.properties
      var segmentID = properties.segment_id;
      
      // mapID is used to keep track of lines and points on the map. 
      //  They could be split, which would make the mapID different 
      //  from the segment_id. If the mapID is already set though, 
      //  that means that this feature was created by splitAtVertex(), 
      //  so don't reassign it
      if (feature.properties["mapID"] == undefined) {
        feature.properties["mapID"] = segmentID;
      }
      
      layer.addEventListener({
        click: (e => onPointClick(e, properties.mapID, properties.point_index, properties.min_index))
      });

      // Add coordinates to dict of coordinate arrays for creating lines later
      var pointCoords = feature.geometry.coordinates;
      if (lineCoords[fileName][segmentID] === undefined) {
        // coords in geojson are [x, y] but polyline needs [lat, lon]
        lineCoords[fileName][segmentID] = [[pointCoords[1], pointCoords[0]]]
      } else {
        lineCoords[fileName][segmentID].push([pointCoords[1], pointCoords[0]])
      }

    }


    function geojsonPointAsCircle(feature, latlng, color) {
      var markerOptions = {
        radius: 8,
        weight: 1,
        opacity: 1,
        fillOpacity: 0.8,
        fillColor: color,
        color: color
      }

      var popup = L.popup({
        autoPan: false,

      })
        .setContent(`
          <div>
            <p><strong>Time:</strong> ${feature.properties.ak_datetime}</p>
            <p><strong>Altitude:</strong> ${feature.properties.altitude_ft} ft</p>
          </div>
        `);

      return L.circleMarker(latlng, markerOptions)
        .bindPopup(popup);
    }


    function showVertices(id) {

      var fileName = getSelectedFileName();//currentFile//$('.collapse.show').text()

      var currentLineID = selectedLines[fileName];
      if (currentLineID >= 0) {
        hideVertices(currentLineID);
      }
      
      var geojsonPoints = pointGeojsonLayers[fileName][id];
      map.addLayer(geojsonPoints);
      map.fitBounds(geojsonPoints.getBounds());
      lineLayers[fileName][id].bringToFront();
      geojsonPoints.bringToFront();

      selectedLines[fileName] = id;
      

    }


    function hideVertices(id) {
      var fileName = getSelectedFileName();//currentFile//$('.collapse.show').text()
      map.removeLayer(pointGeojsonLayers[fileName][id]); 

      //unselect this legend item (if it's selected)
      $('#legend-' + fileName + '-' + id)
        .removeClass('legend-row-selected')
        .addClass('legend-row')
        .children()
          .removeClass('legend-cell-selected')
          .addClass('legend-cell');
    }


    function getLineID(layer) {
      var fileName = getSelectedFileName();//currentFile//$('.collapse.show').text()
      for (var segmentID in lineLayers[fileName]) {
        if (lineLayers[fileName][segmentID] == layer) {
          return segmentID;
        }
      }
    }


    function selectLegendItem(id) {
      /* 
      Make item look selected in the legend
      */

      var fileName = getSelectedFileName()
      // Deselect all currently selected cell (<td>) items,
      //  which actually contain the formatting
      $('.legend-cell-selected')
        .removeClass('legend-cell-selected')
        .addClass('legend-cell');
      
      // Remove the selection class from the row (<tr>)
      $('.legend-row-selected')
        .removeClass('legend-row-selected')
        .addClass('legend-row')

      // The row was a assigned the id, so get it's children (the <td>s)
      //  and add the class that contains the 
      $('#legend-' + fileName + '-' + id)
        .removeClass('legend-row')
        .addClass('legend-row-selected')
        .children()
        .removeClass('legend-cell')
        .addClass('legend-cell-selected');

      // If the checkbox was unselected, select it
      // This only works if legend-row events are filtered and only allowed 
      //  to propogate if the event didn't originate on a checkbox
      var thisCheckbox = $(`#legend-checkmark-${fileName}-${id}`);
      if (!thisCheckbox.prop('checked') && lineLayers[fileName][id] != undefined) {
        thisCheckbox.prop('checked', true);
        lineLayers[fileName][id].addTo(map);
      }
    }


    function onLineClick(e) {
      /*
      When a line is clicked, hide the vertices of the active 
      line and show this line's vertices
      */

      if (!e.originalEvent.ctrlKey) {
        var thisLineID = getLineID(e.target);

        showVertices(thisLineID);

        selectLegendItem(thisLineID);

        var scrollPosition = $(`#legend-${getSelectedFileName()}`).scrollTop();
        var rowHeight = parseInt($(`#legend-${getSelectedFileName()}-${thisLineID}`).css('height').replace('px', ''));
        var legendHeight = parseInt($(`#legend-${getSelectedFileName()}`).css('height').replace('px', ''));
        var scrollTo = thisLineID * rowHeight - rowHeight;

        //$(`#legend-${getSelectedFileName()}-${thisLineID}`).position().top
        if (scrollTo < scrollPosition || scrollTo > scrollPosition + legendHeight) {
          $(`#legend-${getSelectedFileName()}`)
            .animate(
              {scrollTop: scrollTo < 0 ? 0 : scrollTo}, 
              300
            );
        } else {
          var a = 1;
        }
        L.DomEvent.stop(e) // don't propagate to the map
      }
    }


    function deleteCurrentTrack() {
      /*
      Remove the currently selected line and points from the 
      map and delete references to them
      */

      var fileName = getSelectedFileName();
      var currentLineID = selectedLines[fileName];
      if (currentLineID >= 0 && confirm("Are you sure you want to delete the select track?")) {
        map.removeLayer(pointGeojsonLayers[fileName][currentLineID]);
        map.removeLayer(lineLayers[fileName][currentLineID]);
        delete pointGeojsonLayers[fileName][currentLineID];
        delete lineLayers[fileName][currentLineID];
        delete trackInfo[fileName][currentLineID];
        $(`#legend-${fileName}-${currentLineID}`)
          .fadeOut(500, function() {$(this).remove()});// remove the item from the legend
        selectedLines[fileName] = -1;
      } else {
        alert("No track currently selected. Click a track first then press 'Delete'")
      }
      //updateLegend();

    }


    function onKeyDown(e) {

      if (e.key === 'Delete') {
        deleteCurrentTrack();
      }
    }
    

    function onMapClick(e) {
      /*
      If the map is clicked (not a polyline layer), deselect the current layer
      */

      var fileName = getSelectedFileName()
      var currentLineID = selectedLines[fileName]
      if (currentLineID >= 0 && !e.originalEvent.ctrlKey) {
        hideVertices(currentLineID);
        selectedLines[fileName] = -1;
      }
    }


    function addFileToMenu(filePath) {
       
       var fileName = filePath.replace('data/', '').replace('.json', '');
       //$('<tr><td class="file-list-row">' + fileName + '</td></tr>')
       //.appendTo('#files-table')
       var cardID = 'card-' + fileName;
       var cardHeaderID = 'cardHeader-' + fileName;
       var contentID = 'cardContent-' + fileName;
       // add the card
       $('<div class="card" id="' + cardID + '">' + 
            '<div class="card-header px-0" id="' + cardHeaderID + '"></div>' +
          '</div>'
        ).appendTo('#file-list');

       // add an anchor to the card header
       $(`<a class="collapsed card-link text-center" data-toggle="collapse" href="#${contentID}">
            <p class="card-title">${fileName}</p>
          </a>`)
       .appendTo('#' + cardHeaderID)
       .on('click', function() {
        if (!$(this).hasClass('card-header-anchor-selected')){
          
          // Make sure the new card is given the selected class before trying to load data
          fileWasSelected(fileName);
          
          // If the points don't yet exist, this file hasn't been loaded, so load them
          if (pointGeojsonLayers[fileName] == undefined) {
            loadTracksFromJSON(filePath);
          } else {
            loadTracksFromMemory(fileName);
          }
        }
       });

       // Add the card content to the card
       $('<div id="' + contentID + '" class="collapse" aria-labeledby="' + cardHeaderID + '" data-parent="#file-list">' + 
          '<div class="card-body p-0" id="' + contentID + '-body">' +
            '<div class="dark-scrollbar" id="legend-' + fileName + '" style="display:block; width:100%; overflow:auto; max-height:250px;"></div>' +
          '</div>' +
          '<div class="card-footer"></div>' +
        '</div>'
        ).appendTo('#' + cardID);

    }


    function updateLegend(fileName){

      var legendID = 'legend-' + fileName;
      $('#' + legendID).empty();
      
      // Add a new row for each track
      for (segmentID in trackInfo[fileName]) {
        /*// If the element already exists, skip it
        if ($(`#legend-${fileName}-${segmentID}`).length) {
          continue;
        }*/
        var thisInfo = trackInfo[fileName][segmentID];
        var thisColor = colors[fileName][segmentID];
        var htmlString = 
        `
        <div class="legend-row" id="legend-${fileName}-${segmentID}" style="width: 100%;">
          <div class="legend-cell" style="width:90px; text-align:right; padding-right: 10px">
            <svg height="10" width="80">
              <line x1="15" y1="5" x2="65" y2="5" style="stroke:${thisColor}; stroke-width:3;"></line>
            </svg>
          </div>
          <div class="legend-cell" style="width:60%; max-width: 60%">
            <label style="text-align:left;">${thisInfo.departure_datetime}</label>
          </div>
          <div class="legend-cell" style="text-align:center; max-width:10%; width:10%; padding-right:10px; padding-left:10px;">
            <label class="checkmark-container">
              <input type="checkbox" checked="checked" id="legend-checkmark-${fileName}-${segmentID}">
              <span class="checkmark"></span>
            </label>
          </div>
        </div>
        `;
        $(htmlString)
          .click(function(event) {
            // If the event originated on a checkbox, exit
            if ($(event.target).hasClass('checkmark') || $(event.target).attr('checked')) {
              return;
            }

            var thisID = $(this)[0].id.replace('legend-' + fileName + '-', '');
            showVertices(thisID);
            selectLegendItem(thisID);
          })
          .appendTo('#' + legendID);

        // Handle clicks on this item's checkbox
        $('#legend-checkmark-' + fileName + '-' + segmentID).change(function(event) {
          
          var thisID = $(this)[0].id.replace(`legend-checkmark-${fileName}-` , '');
          if (!this.checked) {// state is after click
            if (thisID == selectedLines[fileName]) {
              hideVertices(thisID);
            }
            map.removeLayer(lineLayers[fileName][thisID]);
            trackInfo[fileName][thisID].visible = false;
          } else {
            map.addLayer(lineLayers[fileName][thisID]);
            trackInfo[fileName][thisID].visible = true;
          }
          
          // Make sure the click doesn't continue to the .legend-row and highlight it
          event.stopPropagation();
        })
        
      }
      
      // select the row corresponding to the selected line
      selectLegendItem(selectedLines[fileName]);
      //console.log($('#legend_0'))
    }


    function removeAllLayers() {
      
      map.eachLayer( function(layer) {
        if (!(layer instanceof L.TileLayer)) {
          map.removeLayer(layer);
        }
      })
    }


    function fileWasSelected(filePath) {

      // remove selection if this is not the currently selected file.
      //  otherwise, add -selected style
      $('.collapse.show').collapse('hide')

      var fileName = filePath.replace('data/', '').replace('.json', '');
      
      // remove selected class styling from the .card-header anchor
      var oldFileName = getSelectedFileName();//currentFile
      $('#card-' + oldFileName)
        .css('background-color', 'rgb(75, 75, 75')
          .find('a')
            //.css('color', 'rgb(125, 125, 125)')
            .removeClass('card-header-anchor-selected')
            /*.hover(function() {
              $(this).css('color', 'rgb(125, 125, 125)')
            });*/

      $('.collapse').each(function(){
        var thisFileName = $(this)[0].id.replace('cardContent-', '');
        if (thisFileName == fileName) {
          $(this).collapse('show');

          // Style the card to look selected
          $('#card-' + thisFileName)
            .css('background-color', 'rgb(85, 85, 85)')
            .find('a')
              //.css('color', 'rgb(150, 150, 150)')
              .addClass('card-header-anchor-selected');
            
            if (oldFileName != thisFileName && trackInfo[thisFileName] != undefined) {
              fillTrackInfo();
            } 
        }
      });
      
    }


    function loadTracksFromJSON(filePath) {
      // Read the track JSON file and 

      removeAllLayers();


      var fileName = filePath.replace('data/', '').replace('.json', '')
      
      // Initialize objects for this file
      pointGeojsonLayers[fileName] = {};
      lineLayers[fileName] = {};
      lineCoords[fileName] = {};
      colors[fileName] = {};
      minVertexIndices[fileName] = {};
      fileExtents[fileName] = {};
      trackInfo[fileName] = {};  

      var deferred = $.getJSON(
        filePath,
        function(data) {
          /* data come in as
          {
            track_info: 
              {
                prop1: val1
                ...
              },
            geojsons: 
              {
                0: geojson_data 
                ...
              }
          }*/
          data['track_info']['visible'] = true;
          // Each item in the JSON file is a separate geojson 
          for (segmentID in data.geojsons) {
            var geojson = data.geojsons[segmentID];
            var firstProperties = geojson.features[0].properties
            data.track_info['departure_datetime'] = firstProperties.departure_datetime
            data.track_info['registration'] = firstProperties.registration
            trackInfo[fileName][segmentID] = data.track_info
            
            var color = getColor();
            colors[fileName][segmentID] = color;
            pointGeojsonLayers[fileName][segmentID] = L.geoJSON(geojson, {
              onEachFeature: ((feature, layer) => onEachPoint(feature, layer, fileName)), 
              pointToLayer: ((feature, latlng) => geojsonPointAsCircle(feature, latlng, color))
            });

          }
        }
      ).done(function() {    
        // Once the async call is done, add all the lines and 
        //  the points for a single line to the map
        var polylineCoords = [];
        for (var segmentID in lineCoords[fileName]) {
          var line = L.polyline(
            lineCoords[fileName][segmentID], 
            options={color: colors[fileName][segmentID]}
            )
          .addTo(map);
          line.on({click: onLineClick});
          lineLayers[fileName][segmentID] = line;
          polylineCoords.push(lineCoords[fileName][segmentID]);
        }

        // Show first line
        if (selectedLines[fileName] == undefined) {
          selectedLines[fileName] = 0;
        }

        showVertices(selectedLines[fileName]);
        var allLines = L.polyline(polylineCoords);
        fileExtents[fileName] = allLines.getBounds();
        map.fitBounds(fileExtents[fileName]);

        // Add lines to legend
        updateLegend(fileName);

        // Fill in the rest of the track info (from reading the geojsons)
        fillTrackInfo(); 
      })

      return deferred;
    }


    function loadTracksFromMemory(fileName) {
      
      // remove current layers
      removeAllLayers();

      // Add the lines for this file
      for (segmentID in lineLayers[fileName]) {
        lineLayers[fileName][segmentID].addTo(map);
      }

      // show the right file as selected
      //fileWasSelected(fileName);

      // Update the legend
      updateLegend(fileName);

      //show points for the most recently selected segment
      if (selectedLines[fileName] >= 0) {
        showVertices(selectedLines[fileName]);
      }

      // zoom to extent
      map.fitBounds(fileExtents[fileName])
    }


    function writeJSON(){

      var fileName = $('.file-list-row-selected').text()
      var filePath = 'data/edited/' + fileName.replace('_geojsons.json', '.geojson');
      
      // The point layes are in the format {segID: {geojson}} so just combine all of 
      //  the features into a single FeatureCollection GeoJSON object since the 
      //  segment IDs are also recorded in the properties of each feature
      var features = []
      for (segmentID in pointGeojsonLayers[fileName]) {
        var geojson = pointGeojsonLayers[fileName][segmentID].toGeoJSON();
        for (thisID in geojson) {
          features.push(...geojson[thisID]);
        }
      }
      var thisGeojson = {
        type: "FeatureCollection",
        crs: { type: "name", properties: { name: "urn:ogc:def:crs:OGC:1.3:CRS84" } },
        features: features
      }

      // send a post request to the PHP script
      var data = {
        action: "writeFile",
        filePath: filePath,
        jsonString: JSON.stringify(thisGeojson)
      };

      $.ajax({
        url: 'geojson_io.php',
        method: 'POST',
        data: data,
        success: function(response) {
          if (response == false) {
            alert('JSON data failed to save')
          }
        }
      }).fail(alert('JSON data failed to save'));

    }

    function fillTrackInfo(){

      var fileName = getSelectedFileName();
      var thisInfo = trackInfo[fileName][selectedLines[fileName]];

      // If there's no info for the selected track (= -1), get the first 
      //  one because each track for a given file has the same global track info
      if (thisInfo == undefined) {
        for (segmentID in trackInfo[fileName]) {
          // get the first one
          thisInfo = trackInfo[fileName][segmentID];
          break;
        }
      }

      for (key in thisInfo) {
        //console.log(key + ': ' + thisInfo[key])
        $('#textbox-' + key).val(thisInfo[key]);
        $('#p-' + key).text(thisInfo[key])//for the submitter comments
      }
      //$('#track-info-subtitle').text(`Submitted at ${thisInfo.submission_time}\nby ${thisInfo.submitter}`)
      $('#p-submitted-at').text(`Submitted at ${thisInfo.submission_time}`);
      $('#p-submitted-by').text(`by ${thisInfo.submitter}`);
    }


    //var startPoint = [63.1249, -149.254];
    var map = L.map('map', {editable: true})//.setView(startPoint, 10)
    var tilelayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
      attribution: 'Tiles &copy; Esri &mdash; Source: Esri, DeLorme, 2019'
    }).addTo(map);
    
    map.doubleClickZoom.disable();
    
    var pointGeojsonLayers = {};
    var lineLayers = {};
    var lineCoords = {};
    var colors = {};
    var minVertexIndices = {};
    var trackInfo = {};
    var selectedLines = {};
    var fileExtents = {};
    //var currentFile = ""; // keep track with a global var because Boostrap's .collapse() is asynchonous so the new file might be trying to load before the .show class is added to the .collapse element
    
    function getSelected(){
      return selectedLines['201961_616tail09_geojsons']
    }
    // Make sure files are read from disk every time
    $(document).ready(function() {
      $.ajaxSetup({ cache: false });
      $('#map-container').css('height', $(window).height());

      //
      /*$('#legend-201961_616tail09_geojsons').scroll(function(){
        console.log('scroll position: ' + $('#legend-201961_616tail09_geojsons').scrollTop());
        console.log('row position: ' + $('#legend-201961_616tail09_geojsons-' + getSelected()).position().top);
        console.log('');
      })*/
      //
    });

    $.ajax({
      url: 'geojson_io.php',
      method: 'POST',
      data: {action: "getFiles"},
      success: function(json_string) {
        var files = $.parseJSON(json_string);
        files.forEach(function(filePath) {
          addFileToMenu(filePath);
        })

        fileWasSelected(files[1].replace('data/', '').replace('.json', ''))
        var deferred = loadTracksFromJSON(files[1]) // load any file, doesn't matter which
        
        // When the tracks have finished loading, get track info
        deferred.done(function() {
          $.ajax({
            url: 'geojson_io.php',
            method: 'POST',
            data: {action: 'getUser'},
            success: function(username){
              // If authentication failed, do nothing
              if (username) {
                $('#textbox-track_editor').val(username);
              }
            }
          })
        })
      }

    });

    var deleteEvent = document.addEventListener('keydown', onKeyDown);
    map.addEventListener('click', onMapClick);// {
    $('#save-button').click(writeJSON);

    
  </script>
</body>
</html>
