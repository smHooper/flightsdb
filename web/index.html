<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width,height=device-height, user-scalable=no" />
  <title>Overflight data</title>
  <link rel="stylesheet" href="https://npmcdn.com/leaflet@1.2.0/dist/leaflet.css" />
  <script src="./node_modules/leaflet/dist/leaflet.js"></script>
  <script src="./node_modules/leaflet-filelayer/src/leaflet.filelayer.js"></script>
  <script src="./js/leaflet-providers.js"></script>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <!--<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"/>
  <script src="./Leaflet.Editable/src/Leaflet.Editable.js"></script>-->
  <style type='text/css'>
      body { 
        height: 100%; 
        width: 100%; 
        background-color: black;
      }
      

      
      #menu-container {
        position: relative;
        background-color: black;
        border: 5px;
        border-color: rgb(50, 50, 50);
      }
      
      #map { 
        position: relative; 
        height: 800px; */
        margin-bottom: 0;
        margin-top: 0;
        width:100%;
      }

      .file-list-row {
        height: 50px;
        border: 2px solid rgb(50, 50, 50);
      }

      #dashboard-container {
        padding: 0;
        margin: 0;
      }

      td {
        color: rgb(100, 100, 100);
        text-align: center;
      }
      /*td {
        padding: 10px;
      }*/

  </style>
</head>

<body>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
  <div id="dashboard-container" class="container-fluid" style="background-color: black;">
    
    <div class="row">
      
      <div id='menu-container' class="col-sm-3">
        <table id='files' style="width: 100%">
          <tr class="file-list-row"><td>file1</td></tr>
          <tr class="file-list-row"><td>file2</td></tr>
        </table>
        <!---<p>Lorem ipsum dolor sit amet, qui ea delenit qualisque, ne duo tollit dolore hendrerit. Exerci postulant eos at, has causae electram id. Legimus contentiones eum te, eos eligendi vituperata ad, no ferri offendit referrentur vis. Homero virtute habemus ad sed, nec ferri viris in. Te labore adolescens ius, his consulatu eloquentiam ea, mea nulla appareat dignissim an. Ei his magna expetenda, nihil copiosae quo ut, percipit insolens mea an.</p>-->
      </div>
      
      <div id='map-container' class="col-sm-9">
        <div id='map'></div>
      </div>
    
    </div>

  </div>

  <script type="text/javascript">
    //var startPoint = [63.1249, -149.254];
    var map = L.map('map', {editable: true})//.setView(startPoint, 10)
    var tilelayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
    	attribution: 'Tiles &copy; Esri &mdash; Source: Esri, DeLorme, 2019'
    }).addTo(map);
    
    map.doubleClickZoom.disable();
    
    var pointGeojsonLayers = {};
    var lineLayers = {};
    var lineCoords = {};
    var colors = {};
    var minVertexIndices = {};

    // keep track of line IDs so that when a new line is created (on split), 
    //  it can be given a new ID not found in the original geojson and but 
    //  the import process still knows what line it corresponds to
    var originalLineIDs = {}


    function getColor() {
      var color = Math.floor(Math.random() * 16777216).toString(16);
      var hexColor = '#000000'.slice(0, -color.length) + color;

      return hexColor;
    }


    function splitAtVertex(segmentID, vertexID, minVertexIndex){
      /*
      Split a line at the associated vertex. vertexID is the ID of the 
      point from the geojson used to create it
      */

      var originalLine = lineLayers[segmentID];
      var allLatlngs = originalLine.getLatLngs();

      // vertexID is a global ID so calculate the index within the latlngs array
      var vertexIndex = vertexID - minVertexIndex 

      var originalLatlngs = allLatlngs.slice(0, (vertexIndex + 1));
      var newLatLngs = allLatlngs.slice(vertexIndex);
      
      /*console.log("segmentID: " + segmentID);
      console.log("vertexID: " + vertexID);
      console.log("minVertexIndex: " + minVertexIndex);
      console.log("vertexIndex: " + vertexIndex);*/
      // Set coords for the old line (everything up to the vertex) and 
      //  create the new line (the new vertex and everything after)
      originalLine.setLatLngs(originalLatlngs);
      var newSegmentID = Math.max.apply(null, Object.keys(lineLayers)) + 1;
      var newColor = getColor();
      colors[newSegmentID] = newColor;
      var newLine = L.polyline(
        newLatLngs, 
        options={color: newColor})
      .addEventListener({click: onLineClick})
      .addTo(map);
      lineLayers[newSegmentID] = newLine;

      // Create the new point geojson by looping through all points 
      //  of the original and adding each .feature to the json
      var newGeoJSON = {
        type: "FeatureCollection",
        features: []
      }
      pointGeojsonLayers[segmentID].eachLayer(
        function(layer) {
          var featureID = layer.feature.id;
          var theseCordinates = layer.feature.geometry.coordinates
          var theseProperties = layer.feature.properties
          // only add this point if it occurs after the splitting vertex
          //  (or if it is that vertex)
          if (featureID >= vertexID) {
            // set the mapID to the new segment ID so the points 
            //  are still related to the line
            theseProperties.mapID = newSegmentID;
            theseProperties.min_index = vertexID;
            // add this feature
            newGeoJSON.features.push(layer.feature);

            // if this feature isn't the splitting vertex, 
            //  drop it from the original point layer
            if (featureID > vertexID) {
              pointGeojsonLayers[segmentID].removeLayer(layer)
            };
          }
        }
      )
      pointGeojsonLayers[newSegmentID] = L.geoJSON(newGeoJSON, {
        //**** this doesn't work for some reason (i.e., onEachPoint is never called) *** 
        onEachFeature: onEachPoint, 
        pointToLayer: ((feature, latlng) => geojsonPointAsCircle(feature, latlng, newColor))
      });//.addTo(map);

    }


    function onPointClick(event, segmentID, vertexID, minVertexIndex) {
      if (event.originalEvent.ctrlKey) {
        splitAtVertex(segmentID, vertexID, minVertexIndex)
      }
    }

    function onEachPoint(feature, layer) {
      /*
      For each point, add the coordinates to a dictionary of 
      segmentID: [coords] so lines can be created later  
      */
      var properties = feature.properties
      var seg_id = properties.segment_id;
      
      // mapID is used to keep track of lines and points on the map. 
      //  They could be split, which would make the mapID different 
      //  from the segment_id. If the mapID is already set though, 
      //  that means that this feature was created by splitAtVertex(), 
      //  so don't reassign it
      if (feature.properties["mapID"] == undefined) {
        feature.properties["mapID"] = seg_id;
      }
      
      layer.addEventListener({
        click: (e => onPointClick(e, properties.mapID, properties.point_index, properties.min_index))
      });

      // Add coordinates to dict of coordinate arrays for creating lines later
      var pointCoords = feature.geometry.coordinates;
      if (lineCoords[seg_id] === undefined) {
        // coords in geojson are [x, y] but polyline needs [lat, lon]
        lineCoords[seg_id] = [[pointCoords[1], pointCoords[0]]]
      } else {
        lineCoords[seg_id].push([pointCoords[1], pointCoords[0]])
      }
    }


    function showVertices(id) {

      if (currentLineID >= 0) {
        hideVertices(currentLineID);
      }
      
      var geojsonPoints = pointGeojsonLayers[id];
      map.addLayer(geojsonPoints);
      map.fitBounds(geojsonPoints.getBounds());
      lineLayers[id].bringToFront();
      geojsonPoints.bringToFront();

      currentLineID = id;
    }


    function hideVertices(id) {
        map.removeLayer(pointGeojsonLayers[id]);   
    }


    function getLineID(layer) {
      for (var segmentID in lineLayers) {
        if (lineLayers[segmentID] == layer) {
          return segmentID;
        }
      }
    }


    function onLineClick(e) {
      /*
      When a line is clicked, hide the vertices of the active 
      line and show this line's vertices
      */
      //e.orignalEvent.ctrlKey
      if (!e.originalEvent.ctrlKey) {
        var thisLineID = getLineID(e.target);

        showVertices(thisLineID);
        
        L.DomEvent.stop(e) // don't propagate to the map
      }
    }


    function deleteCurrentTrack() {
      /*
      Remove the currently selected line and points from the 
      map and delete references to them
      */
      // remove from the map
      if (currentLineID >= 0 && confirm("Are you sure you want to delete the select track?")) {
        map.removeLayer(pointGeojsonLayers[currentLineID]);
        map.removeLayer(lineLayers[currentLineID]);
        delete pointGeojsonLayers[currentLineID];
        delete lineLayers[currentLineID];
        currentLineID = -1;
      } else {
        alert("No track currently selected. Click a track first then press 'Delete'")
      }
      
    }

    function onKeyDown(e) {

      if (e.key === 'Delete') {
        deleteCurrentTrack();
      }
    }


    function geojsonPointAsCircle(feature, latlng, color) {
      var markerOptions = {
        radius: 8,
        weight: 1,
        opacity: 1,
        fillOpacity: 0.8,
        fillColor: color,
        color: color
      }
      return L.circleMarker(latlng, markerOptions);
    }

    var currentLineID = 0;
    

    function onMapClick(e) {
      /*
      If the map is clicked (not a polyline layer), deselect the current layer
      */

      if (currentLineID >= 0 && !e.originalEvent.ctrlKey) {
        hideVertices(currentLineID);
        currentLineID = -1;
      }
    }


    $.ajax({
      url: 'geojson_io.php',
      method: 'POST',
      data: {action: "getFiles"},
      success: function(json_string) {
        var files = $.parseJSON(json_string);
        files.forEach(function(filePath) {
          $.getJSON(
            filePath,
            function(data) {
              // Each item in the JSON file is a separate geojson 
              for (var segmentID in data) {
                var geojson = data[segmentID];//$.parseJSON(data[segmentID]);
                var color = getColor();
                colors[segmentID] = color;
                pointGeojsonLayers[segmentID] = L.geoJSON(geojson, {
                  onEachFeature: onEachPoint, 
                  pointToLayer: ((feature, latlng) => geojsonPointAsCircle(feature, latlng, color))
                });
              }
            }
          ).done(function() {    
            // Once the async call is done, add all the lines and 
            //  the points for a single line to the map
            var polylineCoords = [];
            for (var seg_id in lineCoords) {
              var line = L.polyline(lineCoords[seg_id], options={color: colors[seg_id]}).addTo(map);
              line.on({click: onLineClick});
              lineLayers[seg_id] = line;
              originalLineIDs[seg_id] = seg_id
              polylineCoords.push(lineCoords[seg_id]);
            }
            currentLineID = 0;
            showVertices(currentLineID);
            var allLines = L.polyline(polylineCoords);
            map.fitBounds(allLines.getBounds());
          })
        })
      }
    });

    var deleteEvent = document.addEventListener('keydown', onKeyDown);
    //map.addEventListener('click', onMapClick)// {

    
  </script>
</body>
</html>
