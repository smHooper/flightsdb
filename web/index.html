<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width,height=device-height, user-scalable=no" />
  <title>Overflight editor</title>
  <link rel="stylesheet" href="https://npmcdn.com/leaflet@1.2.0/dist/leaflet.css" />
  <script src="./node_modules/leaflet/dist/leaflet.js"></script>
  <script src="./node_modules/leaflet-filelayer/src/leaflet.filelayer.js"></script>
  <script src="./js/leaflet-providers.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
  <link href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" rel="stylesheet" id="bootstrap-css">
  <script src="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"></script>

  <style type='text/css'>
      body { 
        height: 100%; 
        width: 100%; 
        background-color: rgb(50, 50, 50);
      }
      

      #menu-container {
        position: relative;
        border: 5px;
        border-color: rgb(100, 100, 100);
      }
      
      #map { 
        position: relative; 
        height: 800px; */
        margin-bottom: 0;
        margin-top: 0;
        width:100%;
      }

      /*.card-header {
        background-color: rgb(60, 60, 60);
        border-bottom:  
      }*/
      .card {
        /*height: 60px;*/
        /*border: 2px solid rgb(100, 100, 100);*/
        color: rgb(110, 110, 110);
        background-color: rgb(75, 75, 75);

      }

      .card-header:hover {
        font-weight: bold;
        border: 3px solid rgb(100, 100, 100);
        cursor: pointer;
      }

      .show {
        height: 200px;
        /*border: 4px solid rgb(100, 100, 100);*/
        /*font-weight: bold;*/
        color: rgb(125, 125, 125);
        background-color: rgb(60, 60, 60);
        /*box-shadow: 0px 16px 16px 0 rgba(0,0,0,0.2);*/
        text-align: center;
      }

      /*.show:hover {
        cursor: auto;
        border: 4px solid rgb(100, 100, 100);
      }*/

      .legend-row {
        height: 50px;
      }
      
      .legend-row:hover {
        background-color: rgb(65, 65, 70);
        cursor: pointer;
      }

      .legend-row-selected {
        height: 50px;
        background-color: rgb(80, 80, 90);
        cursor: auto;
      }

      .legend-cell {
        color: rgb(100, 100, 100);
        text-align: center;
      }

      .legend-cell-selected {
        color: rgb(130, 130, 130);
        text-align: center;
      }
      
      #dashboard-container {
        padding: 20;
      }

      .data-button {
        height: 50px;
        width: 150px;
        top: 10px;
        position: relative;
        /*padding: 14px 28px;*/
        font-size: 16px;
        background-color: rgb(125, 125, 125);
        color: rgb(200, 200, 200);
        border: none;
        display: inline-block;
      }

      td {
        color: rgb(100, 100, 100);
        text-align: center;
      }

      .dark-scrollbar {
        overflow-y: auto;
      }
      .dark-scrollbar::-webkit-scrollbar-track {
          background-color: rgb(60, 60, 60);
      }
      .dark-scrollbar::-webkit-scrollbar-thumb {
          background-color: rgb(110, 110, 110);
      }


      /* Custom checkbox*/
      /* The container */
      .checkmark-container {
        display: block;
        position: relative;
        cursor: pointer;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }

      /* Hide the browser's default checkbox */
      .checkmark-container input {
        position: absolute;
        opacity: 0;
        cursor: pointer;
        height: 0;
        width: 0;
      }

      /* Create a custom checkbox */
      .checkmark {
        position: absolute;
        top: 0;
        left: 0;
        height: 20px;
        width: 20px;
        background-color: rgb(80, 80, 80);
        vertical-align: center;
        horizontal-align: center;
      }

      /* When the checkbox is checked, make the background lighter */
      .checkmark-container input:checked ~ .checkmark {
        background-color: rgb(100, 100, 100);
      }

      /* Create the checkmark/indicator (hidden when not checked) */
      .checkmark:after {
        content: "";
        position: absolute;
        /*display: none;*/
        opacity: 0;
      }

      /* Show the checkmark when checked */
      .checkmark-container input:checked ~ .checkmark:after {
        /*display: block;*/
        opacity: 1;
      }

      /* Style the checkmark/indicator */
      .checkmark-container .checkmark:after {
        left: 7px;
        top: 2px;
        width: 7px;
        height: 12px;
        border: solid rgb(180, 180, 180);
        border-width: 0 2px 2px 0;
        -webkit-transform: rotate(45deg);
        -ms-transform: rotate(45deg);
        transform: rotate(45deg);
        vertical-align: center;
      }

  </style>
</head>

<body>

  <div id="dashboard-container" class="container-fluid ">
    
    <div class="row h-100" >
      
      <div id='menu-container' class="col-sm-3">
        <div>
          <h3 style="color: rgb(110, 110, 110);">Files to import</h3>
          <div class='accordion' id='file-list'>
            <!--items added dynamically on load -->
          </div>
        </div>
        <div style="max-height: 40%;">
          <table style="width: 100%; background-color: rgb(60, 60, 60)">
            <tr style="text-align: center;">
              <!--<th> </th><th>Departure time</th>-->
            </tr>
            <tbody class="dark-scrollbar" id="legend" style="width:100%; min-height:20%; max-height:40%;">
              <!-- rows added dynamically in js -->
            </tbody>
          </table>
        </div>
      </div>
      
      <div id='map-container' class="col-sm-9">
        <div id='map'></div>

        <div class="row" style="top: 10px;">
          <div class="col-sm-2">
            <button class="button data-button" id="save-button">Save tracks</button>
          </div>
          <div class="col-sm-2">
            <!--<button class="button data-button" id="save-button">Import data</button>-->
          </div>          

        </div>
      </div>
    
    </div>

  </div>

  <script type="text/javascript">


    function getColor() {
      var color = Math.floor(Math.random() * 16777216).toString(16);
      var hexColor = '#000000'.slice(0, -color.length) + color;

      return hexColor;
    }


    function splitAtVertex(segmentID, vertexID, minVertexIndex){
      /*
      Split a line at the associated vertex. vertexID is the ID of the 
      point from the geojson used to create it
      */

      var fileName = $('.collapse.show').text();
      var originalLine = lineLayers[fileName][segmentID];
      var allLatlngs = originalLine.getLatLngs();

      // vertexID is a global ID so calculate the index within the latlngs array
      var vertexIndex = vertexID - minVertexIndex 

      var originalLatlngs = allLatlngs.slice(0, (vertexIndex + 1));
      var newLatLngs = allLatlngs.slice(vertexIndex);
      
      // Set coords for the old line (everything up to the vertex) and 
      //  create the new line (the new vertex and everything after)
      originalLine.setLatLngs(originalLatlngs);
      var newSegmentID = Math.max.apply(null, Object.keys(lineLayers[fileName])) + 1;
      var newColor = getColor();
      colors[fileName][newSegmentID] = newColor;
      var newLine = L.polyline(
        newLatLngs, 
        options={color: newColor})
      .addEventListener({click: onLineClick})
      .addTo(map);
      lineLayers[fileName][newSegmentID] = newLine;

      // Create the new point geojson by looping through all points 
      //  of the original and adding each .feature to the json
      var newDepartureTime = pointGeojsonLayers[fileName][segmentID].toGeoJSON().features[vertexID].properties.ak_datetime
      var newGeoJSON = {
        type: "FeatureCollection",
        features: []
      }
      pointGeojsonLayers[fileName][segmentID].eachLayer(
        function(layer) {
          var featureID = layer.feature.id;
          var theseCordinates = layer.feature.geometry.coordinates
          var theseProperties = layer.feature.properties
          // only add this point if it occurs after the splitting vertex
          //  (or if it is that vertex)
          if (featureID >= vertexID) {
            // set the mapID to the new segment ID so the points 
            //  are still related to the line
            theseProperties.mapID = newSegmentID;
            theseProperties.min_index = vertexID;
            layer.feature.properties.departure_datetime = newDepartureTime;
            // add this feature
            newGeoJSON.features.push(layer.feature);

            // if this feature isn't the splitting vertex, 
            //  drop it from the original point layer
            if (featureID > vertexID) {
              pointGeojsonLayers[fileName][segmentID].removeLayer(layer)
            };
          }
        }
      )
      pointGeojsonLayers[fileName][newSegmentID] = L.geoJSON(newGeoJSON, { 
        onEachFeature: ((feature, layer) => onEachPoint(feature, layer, fileName)), 
        pointToLayer: ((feature, latlng) => geojsonPointAsCircle(feature, latlng, newColor))
      });

      // Update the legend
      var thisInfo = newGeoJSON.features[0].properties;
      thisInfo['visible'] = true;
      trackInfo[fileName][newSegmentID] = thisInfo;
      updateLegend(fileName);

    }


    function onPointClick(event, segmentID, vertexID, minVertexIndex) {
      if (event.originalEvent.ctrlKey) {
        splitAtVertex(segmentID, vertexID, minVertexIndex)
      }
    }


    function onEachPoint(feature, layer, fileName) {
      /*
      For each point, add the coordinates to a dictionary of 
      segmentID: [coords] so lines can be created later  
      */
      var properties = feature.properties
      var segmentID = properties.segment_id;
      
      // mapID is used to keep track of lines and points on the map. 
      //  They could be split, which would make the mapID different 
      //  from the segment_id. If the mapID is already set though, 
      //  that means that this feature was created by splitAtVertex(), 
      //  so don't reassign it
      if (feature.properties["mapID"] == undefined) {
        feature.properties["mapID"] = segmentID;
      }
      
      layer.addEventListener({
        click: (e => onPointClick(e, properties.mapID, properties.point_index, properties.min_index))
      });

      // Add coordinates to dict of coordinate arrays for creating lines later
      var pointCoords = feature.geometry.coordinates;
      if (lineCoords[fileName][segmentID] === undefined) {
        // coords in geojson are [x, y] but polyline needs [lat, lon]
        lineCoords[fileName][segmentID] = [[pointCoords[1], pointCoords[0]]]
      } else {
        lineCoords[fileName][segmentID].push([pointCoords[1], pointCoords[0]])
      }

    }


    function showVertices(id) {

      var fileName = currentFile//$('.collapse.show').text()
      var currentLineID = selectedLines[fileName]
      if (currentLineID >= 0) {
        hideVertices(currentLineID);
      }
      
      var geojsonPoints = pointGeojsonLayers[fileName][id];
      map.addLayer(geojsonPoints);
      map.fitBounds(geojsonPoints.getBounds());
      lineLayers[fileName][id].bringToFront();
      geojsonPoints.bringToFront();

      selectedLines[fileName] = id;
      

    }


    function hideVertices(id) {
      var fileName = currentFile//$('.collapse.show').text()
      map.removeLayer(pointGeojsonLayers[fileName][id]); 

      //unselect this legend item (if it's selected)
      $('#legend_' + id)
        .removeClass('legend-row-selected')
        .addClass('legend-row')
        .children()
          .removeClass('legend-cell-selected')
          .addClass('legend-cell');
    }


    function getLineID(layer) {
      var fileName = $('.collapse.show').text()
      for (var segmentID in lineLayers[fileName]) {
        if (lineLayers[fileName][segmentID] == layer) {
          return segmentID;
        }
      }
    }


    function selectLegendItem(id) {
      /* 
      Make item look selected in the legend
      */

      // Deselect all currently selected cell (<td>) items,
      //  which actually contain the formatting
      $('.legend-cell-selected')
        .removeClass('legend-cell-selected')
        .addClass('legend-cell');
      
      // Remove the selection class from the row (<tr>)
      $('.legend-row-selected')
        .removeClass('legend-row-selected')
        .addClass('legend-row')

      // The row was a assigned the id, so get it's children (the <td>s)
      //  and add the class that contains the 
      $('#legend_' + id)
        .removeClass('legend-row')
        .addClass('legend-row-selected')
        .children()
        .removeClass('legend-cell')
        .addClass('legend-cell-selected');
    }


    function onLineClick(e) {
      /*
      When a line is clicked, hide the vertices of the active 
      line and show this line's vertices
      */
      //e.orignalEvent.ctrlKey
      if (!e.originalEvent.ctrlKey) {
        var thisLineID = getLineID(e.target);

        showVertices(thisLineID);

        selectLegendItem(thisLineID);

        L.DomEvent.stop(e) // don't propagate to the map
      }
    }


    function deleteCurrentTrack() {
      /*
      Remove the currently selected line and points from the 
      map and delete references to them
      */

      // remove from the map
      var fileName = $('.file-list-row-selected').text()
      var currentLineID = selectedLines[fileName]
      if (currentLineID >= 0 && confirm("Are you sure you want to delete the select track?")) {
        map.removeLayer(pointGeojsonLayers[fileName][currentLineID]);
        map.removeLayer(lineLayers[fileName][currentLineID]);
        delete pointGeojsonLayers[fileName][currentLineID];
        delete lineLayers[fileName][currentLineID];
        selectedLines[fileName] = -1;
      } else {
        alert("No track currently selected. Click a track first then press 'Delete'")
      }
      
    }


    function onKeyDown(e) {

      if (e.key === 'Delete') {
        deleteCurrentTrack();
      }
    }


    function geojsonPointAsCircle(feature, latlng, color) {
      var markerOptions = {
        radius: 8,
        weight: 1,
        opacity: 1,
        fillOpacity: 0.8,
        fillColor: color,
        color: color
      }
      return L.circleMarker(latlng, markerOptions);
    }

    //var currentLineID = 0;
    

    function onMapClick(e) {
      /*
      If the map is clicked (not a polyline layer), deselect the current layer
      */

      var currentLineID = selectedLines[$('.collapse.show').text()]
      if (currentLineID >= 0 && !e.originalEvent.ctrlKey) {
        hideVertices(currentLineID);
        selectedLines[$('.collapse.show').text()] = -1;
      }
    }


    function addFileToMenu(filePath) {
       
       var fileName = filePath.replace('data/', '').replace('.json', '');
       //$('<tr><td class="file-list-row">' + fileName + '</td></tr>')
       //.appendTo('#files-table')
       var cardID = 'card-' + fileName;
       var cardHeaderID = 'cardHeader-' + fileName;
       var contentID = 'cardContent-' + fileName;
       // add the card
       $('<div class="card" id="' + cardID + '">' + 
            '<div class="card-header px-0" id="' + cardHeaderID + '"></div>' +
          '</div>'
        ).appendTo('#file-list');

       // add an anchor to the card header
       $(`<a class="collapsed card-link text-center" data-toggle="collapse" href="#${contentID}">
            <p class="card-title" style="color: rgb(110, 110, 110);">${fileName}</p>
          </a>`)
       .appendTo('#' + cardHeaderID)
       .on('click', function() {
        if (!$(this).children().hasClass('show')){
          if (pointGeojsonLayers[fileName] == undefined) {
            loadTracksFromJSON(filePath);
          } else {
            loadTracksFromMemory(fileName);
          }
        }
       });
       // Add the card content to the card
       $('<div id="' + contentID + '" class="collapse" aria-labeledby="' + cardHeaderID + '" data-parent="#file-list">' + 
          '<div class="card-body" id="' + contentID + '-body">' +
            '<table clas="style="width: 100%; background-color: rgb(60, 60, 60)">' +
              '<tbody class="dark-scrollbar" id="legend-' + fileName + '" style="display:block; width:100%; overflow-y:auto; max-height:200px">' +
                //'<tr><td>symbol</td><td>departure</td><td>visible</td></tr>' + 
              '</tbody>' +
            '</table>' + 
          '</div>' +
        '</div>'
        ).appendTo('#' + cardID);

    }


    function updateLegend(fileName){

      // remove all items from the current legend if it exists. If not, create it
      var legendID = 'legend-' + fileName;
      // Add a new row for each track
      for (segmentID in trackInfo[fileName]) {
        var thisInfo = trackInfo[fileName][segmentID];

        var thisColor = colors[fileName][segmentID];
        var htmlString = (
          '<tr class="legend-row" id="legend-' + fileName + '-' + segmentID + '" style="width: 100%;" >' +
            '<td class="legend-cell" style="width:90px; text-align:right; padding-right: 10px">' + 
              '<svg height="10" width="80">' + 
                '<line x1="15" y1="5" x2="65" y2="5" style="stroke:' + thisColor + '; stroke-width:3;"/>' +
              '</svg>' + 
            '</td>' + 
            '<td class="legend-cell" style="text-align:left;">' + 
              thisInfo.departure_datetime + 
            '</td>' +
            '<td class="legend-cell" style="text-align:center; padding-right:10px; padding-left:10px;">' + 
              '<label class="checkmark-container">' +
                '<input type="checkbox" checked="checked" id="legend-checkmark-' + fileName + '-' + segmentID + '">' +
                '<span class="checkmark"></span>' +
              '</label>' + 
            '</td>' +
          '</tr>'
        )
        $(htmlString)
          .click(function() {
            var thisID = $(this)[0].id.replace('legend-' + fileName + '-', '');
            showVertices(thisID);
            selectLegendItem(thisID);
          })
          .appendTo('#' + legendID);

        // Handle clicks on this item's checkbox
        $('#legend-checkmark-' + fileName + '-' + segmentID).change(function() {
          var thisID = $(this)[0].id.replace('legend-checkmark-' + fileName, '');

          if (!this.checked) {// state is after click
            if (thisID == selectedLines[fileName]) {
              hideVertices(thisID);
            }
            map.removeLayer(lineLayers[fileName][thisID]);
            trackInfo[fileName][thisID].visible = false;
          } else {
            map.addLayer(lineLayers[fileName][thisID]);
            trackInfo[fileName][thisID].visible = true;
          }

        })

      // select the row corresponding to the selected line
      selectLegendItem(selectedLines[fileName]);
      }

      //console.log($('#legend_0'))
    }


    function removeAllLayers() {
      
      map.eachLayer( function(layer) {
        if (!(layer instanceof L.TileLayer)) {
          map.removeLayer(layer);
        }
      })
    }


    function fileWasSelected(filePath) {
      // remove selection if this is not the currently selected file.
      //  otherwise, add -selected style
      $('.collapse.show').collapse('hide')
      //  .removeClass('show')
        //.addClass('file-list-row');
      $('.collapse').each(function(){
        if ($(this).text() == filePath.replace('data/', '').replace('.json', '')) {
          $(this).collapse('show');
          currentFile = filePath.replace('data/', '').replace('.json', '');
        }
      });
      
    }


    function loadTracksFromJSON(filePath) {
      // Read the track JSON file and 

      removeAllLayers();


      var fileName = filePath.replace('data/', '').replace('.json', '')
      
      // Initialize objects for this file
      pointGeojsonLayers[fileName] = {};
      lineLayers[fileName] = {};
      lineCoords[fileName] = {};
      colors[fileName] = {};
      minVertexIndices[fileName] = {};
      fileExtents[fileName] = {};
      trackInfo[fileName] = {};  

      $.getJSON(
        filePath,
        function(data) {
          // Each item in the JSON file is a separate geojson 
          for (var segmentID in data) {
            var geojson = data[segmentID];//$.parseJSON(data[segmentID]);
            var color = getColor();
            colors[fileName][segmentID] = color;
            pointGeojsonLayers[fileName][segmentID] = L.geoJSON(geojson, {
              onEachFeature: ((feature, layer) => onEachPoint(feature, layer, fileName)), 
              pointToLayer: ((feature, latlng) => geojsonPointAsCircle(feature, latlng, color))
            });
          }
        }
      ).done(function() {    
        // Once the async call is done, add all the lines and 
        //  the points for a single line to the map
        var polylineCoords = [];
        for (var segmentID in lineCoords[fileName]) {
          var line = L.polyline(
            lineCoords[fileName][segmentID], 
            options={color: colors[fileName][segmentID]}
            )
          .addTo(map);
          line.on({click: onLineClick});
          lineLayers[fileName][segmentID] = line;
          polylineCoords.push(lineCoords[fileName][segmentID]);
           
          // Add info for the legend if it hasn't already been added
          var thisInfo = pointGeojsonLayers[fileName][segmentID].toGeoJSON().features[0].properties;
          thisInfo['visible'] = true;
          trackInfo[fileName][segmentID] = thisInfo;
        }

        fileWasSelected(fileName);

        // Show first line
        if (selectedLines[fileName] == undefined) {
          selectedLines[fileName] = 0;
        }
        showVertices(selectedLines[fileName]);
        var allLines = L.polyline(polylineCoords);
        fileExtents[fileName] = allLines.getBounds();
        map.fitBounds(fileExtents[fileName]);

        // Add lines to legend
        updateLegend(fileName);

      })


    }


    function loadTracksFromMemory(fileName) {
      
      // remove current layers
      removeAllLayers();

      // Add the lines for this file
      for (segmentID in lineLayers[fileName]) {
        lineLayers[fileName][segmentID].addTo(map);
      }

      // show the right file as selected
      fileWasSelected(fileName);

      // Update the legend
      updateLegend(fileName);

      //show points for the most recently selected segment
      if (selectedLines[fileName] >= 0) {
        showVertices(selectedLines[fileName]);
      }

      // zoom to extent
      map.fitBounds(fileExtents[fileName])
    }


    function writeJSON(){

      var fileName = $('.file-list-row-selected').text()
      var filePath = 'data/edited/' + fileName.replace('_geojsons.json', '.geojson');
      
      // The point layes are in the format {segID: {geojson}} so just combine all of 
      //  the features into a single FeatureCollection GeoJSON object since the 
      //  segment IDs are also recorded in the properties of each feature
      var features = []
      for (segmentID in pointGeojsonLayers[fileName]) {
        var geojson = pointGeojsonLayers[fileName][segmentID].toGeoJSON();
        for (thisID in geojson) {
          features.push(...geojson[thisID]);
        }
      }
      var thisGeojson = {
        type: "FeatureCollection",
        crs: { type: "name", properties: { name: "urn:ogc:def:crs:OGC:1.3:CRS84" } },
        features: features
      }

      // send a post request to the PHP script
      var data = {
        action: "writeFile",
        filePath: filePath,
        jsonString: JSON.stringify(thisGeojson)
      };

      $.ajax({
        url: 'geojson_io.php',
        method: 'POST',
        data: data,
        success: function(response) {
          if (response == false) {
            alert('JSON data failed to save')
          }
        }
      }).fail(alert('JSON data failed to save'));

    }


    //var startPoint = [63.1249, -149.254];
    var map = L.map('map', {editable: true})//.setView(startPoint, 10)
    var tilelayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
      attribution: 'Tiles &copy; Esri &mdash; Source: Esri, DeLorme, 2019'
    }).addTo(map);
    
    map.doubleClickZoom.disable();
    
    var pointGeojsonLayers = {};
    var lineLayers = {};
    var lineCoords = {};
    var colors = {};
    var minVertexIndices = {};
    var trackInfo = {};
    var selectedLines = {};
    var fileExtents = {};
    var currentFile = ""; // keep track with a global var because Boostrap's .collapse() is asynchonous so the new file might be trying to load before the .show class is added to the .collapse element

    $.ajax({
      url: 'geojson_io.php',
      method: 'POST',
      data: {action: "getFiles"},
      success: function(json_string) {
        var files = $.parseJSON(json_string);
        files.forEach(function(filePath) {
          addFileToMenu(filePath);
        })
        currentFile = files[1].replace('data/', '').replace('.json', '')
        loadTracksFromJSON(files[1]) // load any file, doesn't matter which
      }
    });

    var deleteEvent = document.addEventListener('keydown', onKeyDown);
    map.addEventListener('click', onMapClick);// {
    $('#save-button').click(writeJSON);

    
  </script>
</body>
</html>
