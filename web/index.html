<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width,height=device-height, user-scalable=no" />
  <title>Overflight editor</title>
  <link rel="stylesheet" href="https://npmcdn.com/leaflet@1.2.0/dist/leaflet.css" />
  <script src="./node_modules/leaflet/dist/leaflet.js"></script>
  <script src="./node_modules/leaflet-filelayer/src/leaflet.filelayer.js"></script>
  <script src="./js/leaflet-providers.js"></script>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <!--<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"/>
  <script src="./Leaflet.Editable/src/Leaflet.Editable.js"></script>-->
  <style type='text/css'>
      body { 
        height: 100%; 
        width: 100%; 
        background-color: rgb(50, 50, 50);
      }
      

      #menu-container {
        position: relative;
        border: 5px;
        border-color: rgb(100, 100, 100);
      }
      
      #map { 
        position: relative; 
        height: 800px; */
        margin-bottom: 0;
        margin-top: 0;
        width:100%;
      }

      .file-list-row {
        height: 50px;
        border: 2px solid rgb(100, 100, 100);
        color: rgb(110, 110, 110);
      }

      .file-list-row:hover {
        font-weight: bold;
        border: 3px solid rgb(100, 100, 100);
        cursor: pointer;
      }

      .file-list-row-selected {
        height: 50px;
        border: 4px solid rgb(100, 100, 100);
        font-weight: bold;
        color: rgb(125, 125, 125);
        background-color: rgb(75, 75, 75);
        box-shadow: 0px 16px 16px 0 rgba(0,0,0,0.2);
        text-align: center;
      }

      .file-list-row-selected:hover {
        cursor: auto;
        border: 4px solid rgb(100, 100, 100);
      }

      .legend-row {
        height: 50px;
      }

      .legend-row-selected {
        height: 50px;
        background-color: rgb(90, 90, 90);
      }

      .legend-cell {
        color: rgb(100, 100, 100);
        text-align: center;
      }

      .legend-cell-selected {
        color: rgb(130, 130, 130);
        text-align: center;
      }
      
      #dashboard-container {
        padding: 20;
      }

      .data-button {
        height: 50px;
        width: 150px;
        top: 10px;
        position: relative;
        /*padding: 14px 28px;*/
        font-size: 16px;
        background-color: rgb(125, 125, 125);
        color: rgb(200, 200, 200);
        border: none;
        display: inline-block;
      }

      td {
        color: rgb(100, 100, 100);
        text-align: center;
      }

      .dark-scrollbar {
        overflow-y: auto;
      }
      .dark-scrollbar::-webkit-scrollbar-track {
          background-color: rgb(60, 60, 60);
      }
      .dark-scrollbar::-webkit-scrollbar-thumb {
          background-color: rgb(110, 110, 110);
      }


  </style>
</head>

<body>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
  <div id="dashboard-container" class="container-fluid ">
    
    <div class="row h-100" >
      
      <div id='menu-container' class="col-sm-3">
        <div>
          <h3 style="color: rgb(110, 110, 110);">Files to import</h3>
          <div class="dark-scrollbar">
            <table id='files-table' style="width: 100%; max-height: 30%; background-color: rgb(60, 60, 60)">
              <!-- rows added dynamically in js -->
            </table>
          </div>
        </div>
        <div style="max-height: 40%;">
          <table style="width: 100%; background-color: rgb(60, 60, 60)">
            <tr style="text-align: center;">
              <!--<th> </th><th>Departure time</th>-->
            </tr>
            <tbody class="dark-scrollbar" id="legend" style="display: block; width:100%; max-height:40%;">
              <!-- rows added dynamically in js -->
            </tbody>
          </table>
        </div>
      </div>
      
      <div id='map-container' class="col-sm-9">
        <div id='map'></div>

        <div class="row" style="top: 10px;">
          <div class="col-sm-2">
            <button class="button data-button" id="save-button">Save tracks</button>
          </div>
          <div class="col-sm-2">
            <!--<button class="button data-button" id="save-button">Import data</button>-->
          </div>          

        </div>
      </div>
    
    </div>

  </div>

  <script type="text/javascript">


    function getColor() {
      var color = Math.floor(Math.random() * 16777216).toString(16);
      var hexColor = '#000000'.slice(0, -color.length) + color;

      return hexColor;
    }


    function splitAtVertex(segmentID, vertexID, minVertexIndex){
      /*
      Split a line at the associated vertex. vertexID is the ID of the 
      point from the geojson used to create it
      */

      var fileName = $('.file-list-row-selected').text();
      var originalLine = lineLayers[fileName][segmentID];
      var allLatlngs = originalLine.getLatLngs();

      // vertexID is a global ID so calculate the index within the latlngs array
      var vertexIndex = vertexID - minVertexIndex 

      var originalLatlngs = allLatlngs.slice(0, (vertexIndex + 1));
      var newLatLngs = allLatlngs.slice(vertexIndex);
      
      // Set coords for the old line (everything up to the vertex) and 
      //  create the new line (the new vertex and everything after)
      originalLine.setLatLngs(originalLatlngs);
      var newSegmentID = Math.max.apply(null, Object.keys(lineLayers[fileName])) + 1;
      var newColor = getColor();
      colors[fileName][newSegmentID] = newColor;
      var newLine = L.polyline(
        newLatLngs, 
        options={color: newColor})
      .addEventListener({click: onLineClick})
      .addTo(map);
      lineLayers[fileName][newSegmentID] = newLine;

      // Create the new point geojson by looping through all points 
      //  of the original and adding each .feature to the json
      var newDepartureTime = pointGeojsonLayers[fileName][segmentID].toGeoJSON().features[vertexID].properties.ak_datetime
      var newGeoJSON = {
        type: "FeatureCollection",
        features: []
      }
      pointGeojsonLayers[fileName][segmentID].eachLayer(
        function(layer) {
          var featureID = layer.feature.id;
          var theseCordinates = layer.feature.geometry.coordinates
          var theseProperties = layer.feature.properties
          // only add this point if it occurs after the splitting vertex
          //  (or if it is that vertex)
          if (featureID >= vertexID) {
            // set the mapID to the new segment ID so the points 
            //  are still related to the line
            theseProperties.mapID = newSegmentID;
            theseProperties.min_index = vertexID;
            layer.feature.properties.departure_datetime = newDepartureTime;
            // add this feature
            newGeoJSON.features.push(layer.feature);

            console.log(layer.feature)

            // if this feature isn't the splitting vertex, 
            //  drop it from the original point layer
            if (featureID > vertexID) {
              pointGeojsonLayers[fileName][segmentID].removeLayer(layer)
            };
          }
        }
      )
      pointGeojsonLayers[fileName][newSegmentID] = L.geoJSON(newGeoJSON, { 
        onEachFeature: ((feature, layer) => onEachPoint(feature, layer, fileName)), 
        pointToLayer: ((feature, latlng) => geojsonPointAsCircle(feature, latlng, newColor))
      });

      // Update the legend
      var thisInfo = newGeoJSON.features[0].properties;
      thisInfo['visible'] = true;
      trackInfo[fileName][newSegmentID] = thisInfo;
      updateLegend(fileName);

    }


    function onPointClick(event, segmentID, vertexID, minVertexIndex) {
      if (event.originalEvent.ctrlKey) {
        splitAtVertex(segmentID, vertexID, minVertexIndex)
      }
    }


    function onEachPoint(feature, layer, fileName) {
      /*
      For each point, add the coordinates to a dictionary of 
      segmentID: [coords] so lines can be created later  
      */
      var properties = feature.properties
      var segmentID = properties.segment_id;
      
      // mapID is used to keep track of lines and points on the map. 
      //  They could be split, which would make the mapID different 
      //  from the segment_id. If the mapID is already set though, 
      //  that means that this feature was created by splitAtVertex(), 
      //  so don't reassign it
      if (feature.properties["mapID"] == undefined) {
        feature.properties["mapID"] = segmentID;
      }
      
      layer.addEventListener({
        click: (e => onPointClick(e, properties.mapID, properties.point_index, properties.min_index))
      });

      // Add coordinates to dict of coordinate arrays for creating lines later
      var pointCoords = feature.geometry.coordinates;
      if (lineCoords[fileName][segmentID] === undefined) {
        // coords in geojson are [x, y] but polyline needs [lat, lon]
        lineCoords[fileName][segmentID] = [[pointCoords[1], pointCoords[0]]]
      } else {
        lineCoords[fileName][segmentID].push([pointCoords[1], pointCoords[0]])
      }

    }


    function showVertices(id) {

      var fileName = $('.file-list-row-selected').text()
      var currentLineID = selectedLines[fileName]
      console.log(currentLineID)
      if (currentLineID >= 0) {
        hideVertices(currentLineID);
      }
      
      var geojsonPoints = pointGeojsonLayers[fileName][id];
      map.addLayer(geojsonPoints);
      map.fitBounds(geojsonPoints.getBounds());
      lineLayers[fileName][id].bringToFront();
      geojsonPoints.bringToFront();

      selectedLines[fileName] = id;
      //console.log(selectedLines[$('.file-list-row-selected').text()])

    }


    function hideVertices(id) {
      var fileName = $('.file-list-row-selected').text()
      map.removeLayer(pointGeojsonLayers[fileName][id]);   
    }


    function getLineID(layer) {
      var fileName = $('.file-list-row-selected').text()
      for (var segmentID in lineLayers[fileName]) {
        if (lineLayers[fileName][segmentID] == layer) {
          return segmentID;
        }
      }
    }


    function selectLegendItem(id) {
      /* 
      Make item look selected in the legend
      */

      // Deselect all currently selected cell (<td>) items,
      //  which actually contain the formatting
      $('.legend-cell-selected')
        .removeClass('legend-cell-selected')
        .addClass('legend-cell');
      
      // Remove the selection class from the row (<tr>)
      $('.legend-row-selected')
        .removeClass('legend-row-selected')
        .addClass('legend-row')

      // The row was a assigned the id, so get it's children (the <td>s)
      //  and add the class that contains the 
      $('#legend_' + id)
        .removeClass('legend-row')
        .addClass('legend-row-selected')
        .children()
        .removeClass('legend-cell')
        .addClass('legend-cell-selected');

        console.log($('#legend_' + id))
        console.log($('#legend_' + id).children())
    }


    function onLineClick(e) {
      /*
      When a line is clicked, hide the vertices of the active 
      line and show this line's vertices
      */
      //e.orignalEvent.ctrlKey
      if (!e.originalEvent.ctrlKey) {
        var thisLineID = getLineID(e.target);

        showVertices(thisLineID);

        selectLegendItem(thisLineID);

        L.DomEvent.stop(e) // don't propagate to the map
      }
    }


    function deleteCurrentTrack() {
      /*
      Remove the currently selected line and points from the 
      map and delete references to them
      */

      // remove from the map
      var fileName = $('.file-list-row-selected').text()
      var currentLineID = selectedLines[fileName]
      if (currentLineID >= 0 && confirm("Are you sure you want to delete the select track?")) {
        map.removeLayer(pointGeojsonLayers[fileName][currentLineID]);
        map.removeLayer(lineLayers[fileName][currentLineID]);
        delete pointGeojsonLayers[fileName][currentLineID];
        delete lineLayers[fileName][currentLineID];
        selectedLines[fileName] = -1;
      } else {
        alert("No track currently selected. Click a track first then press 'Delete'")
      }
      
    }


    function onKeyDown(e) {

      if (e.key === 'Delete') {
        deleteCurrentTrack();
      }
    }


    function geojsonPointAsCircle(feature, latlng, color) {
      var markerOptions = {
        radius: 8,
        weight: 1,
        opacity: 1,
        fillOpacity: 0.8,
        fillColor: color,
        color: color
      }
      return L.circleMarker(latlng, markerOptions);
    }

    //var currentLineID = 0;
    

    function onMapClick(e) {
      /*
      If the map is clicked (not a polyline layer), deselect the current layer
      */

      var currentLineID = selectedLines[$('.file-list-row-selected').text()]
      if (currentLineID >= 0 && !e.originalEvent.ctrlKey) {
        hideVertices(currentLineID);
        selectedLines[$('.file-list-row-selected').text()] = -1;
      }
    }


    function addFileToMenu(filePath) {
       
       var fileName = filePath.replace('data/', '')
       $('<tr><td class="file-list-row">' + fileName + '</td></tr>')
       .appendTo('#files-table')
       .on('click', function() {
        if (!$(this).children().hasClass('file-list-row-selected')){
          if (pointGeojsonLayers[fileName] == undefined) {
            loadTracksFromJSON(filePath);
          } else {
            loadTracksFromMemory(fileName);
          }
        }
       });
    }


    function updateLegend(fileName){

      // remove all items from the current legend
      $('#legend').empty();

      // Add a new row for each track
      for (segmentID in trackInfo[fileName]) {
        var thisInfo = trackInfo[fileName][segmentID];
        
        console.log(thisInfo)

        var thisColor = colors[fileName][segmentID];
        var htmlString = (
          '<tr class="legend-row" id="legend_' + thisInfo.mapID + '">' +
            '<td class="legend-cell">' + 
              '<svg height="10" width="80">' + 
                '<line x1="15" y1="5" x2="65" y2="5" style="stroke:' + thisColor + '; stroke-width:3;"/>' +
              '</svg>' + 
            '</td>' + 
            '<td class="legend-cell">' + 
              thisInfo.departure_datetime + 
            '</td>' +
          '</tr>'
        )
        $(htmlString).appendTo('#legend');

      // select the row corresponding to the selected line
      selectLegendItem(selectedLines[fileName])
      }
    }


    function removeAllLayers() {
      
      map.eachLayer( function(layer) {
        if (!(layer instanceof L.TileLayer)) {
          map.removeLayer(layer);
        }
      })
    }


    function fileWasSelected(filePath) {
        // remove selection if this is not the currently selected file.
        //  otherwise, add -selected style
        $('.file-list-row-selected')
          .removeClass('file-list-row-selected')
          .addClass('file-list-row');
        $('.file-list-row').each(function(){
          if ($(this).text() == filePath.replace('data/', '')) {
            $(this).addClass('file-list-row-selected');
          }
        });
    }


    function loadTracksFromJSON(filePath) {
      // Read the track JSON file and 

      removeAllLayers();


      var fileName = filePath.replace('data/', '')
      
      // Initialize objects for this file
      pointGeojsonLayers[fileName] = {};
      lineLayers[fileName] = {};
      lineCoords[fileName] = {};
      colors[fileName] = {};
      minVertexIndices[fileName] = {};
      fileExtents[fileName] = {};
      trackInfo[fileName] = {};  

      $.getJSON(
        filePath,
        function(data) {
          // Each item in the JSON file is a separate geojson 
          for (var segmentID in data) {
            var geojson = data[segmentID];//$.parseJSON(data[segmentID]);
            var color = getColor();
            colors[fileName][segmentID] = color;
            pointGeojsonLayers[fileName][segmentID] = L.geoJSON(geojson, {
              onEachFeature: ((feature, layer) => onEachPoint(feature, layer, fileName)), 
              pointToLayer: ((feature, latlng) => geojsonPointAsCircle(feature, latlng, color))
            });
          }
        }
      ).done(function() {    
        // Once the async call is done, add all the lines and 
        //  the points for a single line to the map
        var polylineCoords = [];
        for (var segmentID in lineCoords[fileName]) {
          var line = L.polyline(
            lineCoords[fileName][segmentID], 
            options={color: colors[fileName][segmentID]}
            )
          .addTo(map);
          line.on({click: onLineClick});
          lineLayers[fileName][segmentID] = line;
          polylineCoords.push(lineCoords[fileName][segmentID]);
           
          // Add info for the legend if it hasn't already been added
          var thisInfo = pointGeojsonLayers[fileName][segmentID].toGeoJSON().features[0].properties;
          thisInfo['visible'] = true;
          trackInfo[fileName][segmentID] = thisInfo;
        }

        fileWasSelected(fileName);

        // Show first line
        if (selectedLines[fileName] == undefined) {
          selectedLines[fileName] = 0;
        }
        showVertices(selectedLines[fileName]);
        var allLines = L.polyline(polylineCoords);
        fileExtents[fileName] = allLines.getBounds();
        map.fitBounds(fileExtents[fileName]);

        // Add lines to legend
        updateLegend(fileName);

      })


    }


    function loadTracksFromMemory(fileName) {
      
      // remove current layers
      removeAllLayers();

      // Add the lines for this file
      for (segmentID in lineLayers[fileName]) {
        lineLayers[fileName][segmentID].addTo(map);
      }

      // show the right file as selected
      fileWasSelected(fileName);

      // Update the legend
      updateLegend(fileName);

      //show points for the most recently selected segment
      if (selectedLines[fileName] >= 0) {
        showVertices(selectedLines[fileName]);
      }

      // zoom to extent
      map.fitBounds(fileExtents[fileName])
    }


    function writeJSON(){

      var fileName = $('.file-list-row-selected').text()
      var filePath = 'data/edited/' + fileName.replace('_geojsons.json', '.geojson');
      
      // The point layes are in the format {segID: {geojson}} so just combine all of 
      //  the features into a single FeatureCollection GeoJSON object since the 
      //  segment IDs are also recorded in the properties of each feature
      var features = []
      for (segmentID in pointGeojsonLayers[fileName]) {
        var geojson = pointGeojsonLayers[fileName][segmentID].toGeoJSON();
        for (thisID in geojson) {
          features.push(...geojson[thisID]);
        }
      }
      var thisGeojson = {
        type: "FeatureCollection",
        crs: { type: "name", properties: { name: "urn:ogc:def:crs:OGC:1.3:CRS84" } },
        features: features
      }

      // send a post request to the PHP script
      var data = {
        action: "writeFile",
        filePath: filePath,
        jsonString: JSON.stringify(thisGeojson)
      };

      $.ajax({
        url: 'geojson_io.php',
        method: 'POST',
        data: data,
        success: function(response) {
          if (response == false) {
            alert('JSON data failed to save')
          }
        }
      }).fail(alert('JSON data failed to save'));

    }


    //var startPoint = [63.1249, -149.254];
    var map = L.map('map', {editable: true})//.setView(startPoint, 10)
    var tilelayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
      attribution: 'Tiles &copy; Esri &mdash; Source: Esri, DeLorme, 2019'
    }).addTo(map);
    
    map.doubleClickZoom.disable();
    
    var pointGeojsonLayers = {};
    var lineLayers = {};
    var lineCoords = {};
    var colors = {};
    var minVertexIndices = {};
    var trackInfo = {};
    var selectedLines = {};
    var fileExtents = {};

    $.ajax({
      url: 'geojson_io.php',
      method: 'POST',
      data: {action: "getFiles"},
      success: function(json_string) {
        var files = $.parseJSON(json_string);
        files.forEach(function(filePath) {
          addFileToMenu(filePath);
        })
        loadTracksFromJSON(files[0]) // load any file, doesn't matter which
      }
    });

    var deleteEvent = document.addEventListener('keydown', onKeyDown);
    map.addEventListener('click', onMapClick);// {
    $('#save-button').click(writeJSON);

    
  </script>
</body>
</html>
